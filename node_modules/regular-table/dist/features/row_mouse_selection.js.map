{"version":3,"sources":["row_mouse_selection.md"],"names":[],"mappings":"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","sourcesContent":["# Mouse Row Selection\n\nMouse row selection is a feature common in most grids. We expect that when we\n`\"click\"` on the row or row header then the row shows as selected. In this\nexample, the rows are grouped as well, and when the group is selected then rows\nunder the group should show as selected too. We'll also allow the user to make\nmultiple selections when holding down the `ctrl` or `metaKey`.\n\nSounds like the bulk of the logic belongs in a `\"click\"` `EventListener`, so our\n`addRowMouseSelection()` should take a `table` and add a `clickListener()`.\n\nIt will also be responsible for adding the `StyleListener` to ensure the\nselection shows correctly as the `table` scrolls.\n\n# API\n\n```html\n<regular-table id=\"example_table\"></regular-table>\n```\n\nWe can load default selections to this example and wire up the `DataListener`\nborrowed from `two_billion_rows`, and then we simply `addRowMouseSelection()` to\nthe `table` and `draw()`.\n\n```html\n<script type=\"module\">\n    import { addRowMouseSelection } from \"./row_mouse_selection.js\";\n    import { dataListener } from \"/dist/examples/two_billion_rows.js\";\n\n    window.addEventListener(\"load\", () => {\n        const dl = dataListener(200, 50);\n        example_table.setDataListener(dl);\n        addRowMouseSelection(example_table, dl, {\n            selected: [\n                {\n                    row_header: [\"Group 10\", \"Row 11\"],\n                    y0: 11,\n                    y1: 11,\n                },\n                {\n                    row_header: [\"Group 10\", \"Row 15\"],\n                    y0: 14,\n                    y1: 15,\n                },\n                {\n                    row_header: [\"Group 10\", \"Row 18\"],\n                    y0: 17,\n                    y1: 18,\n                },\n            ],\n        });\n        example_table.draw();\n    });\n</script>\n```\n\n## `addRowMouseSelection()`\n\nLets make the row selection behavior available with a single function,\n`addRowMouseSelection()`, that takes a `<regular-table>` and the `DataListener`\nthen applies our behavior on `\"click\"`.\n\n```javascript\nconst PRIVATE = Symbol(\"Row Mouse Selection\");\nconst MOUSE_SELECTED_ROW_CLASS = \"mouse-selected-row\";\n\nexport const addRowMouseSelection = (\n    table,\n    dl,\n    {\n        cellSelectionEnabled = true,\n        className = MOUSE_SELECTED_ROW_CLASS,\n        selected = [],\n    } = {}\n) => {\n    table[PRIVATE] = { selected_rows: selected };\n\n    const clickListener = (event) => {\n        const meta = table.getMeta(event.target);\n\n        const headerWasClicked =\n            meta && typeof meta.row_header_x !== \"undefined\" && meta.row_header;\n\n        const cellWasClicked =\n            meta && typeof meta.y !== \"undefined\" && !meta.column_header_y;\n\n        if (headerWasClicked) {\n            table[PRIVATE] = {\n                selected_rows: newRowSelections(table, meta, event, dl),\n            };\n        } else if (cellWasClicked && cellSelectionEnabled) {\n            table[PRIVATE] = {\n                selected_rows: newRowSelections(table, meta, event, dl),\n            };\n        } else if (!event.ctrlKey && !event.metaKey) {\n            table[PRIVATE] = { selected_rows: [] };\n        }\n        table.draw();\n    };\n\n    table.addEventListener(\"click\", clickListener);\n    addRowSelectionStyleListener(table, dl, className);\n    return table;\n};\n```\n\nOur internal `clickListener()` will need to keep track of the information that\ndescribes our row selection. The properties we're interested in will overlap a\nbit with the `MetaData` `object`, and we'll refer to an `object` with the below\nproperties as a `RowSelection`.\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| [y0] | `number` | The `y` index that begins the selection. |\n| [y1] | `number` | The `y` index that ends the selection. |\n| [row_header_x] | `number` | The `y` of this header's `row_header`. |\n| [row_header] | <code>Array.<object></code> | Header selections. |\n\nWe'll add them to a collection, say keyed on the `table`. In our\n`clickListener()`, we'll check if the `headerWasClicked` and if so, we can\nupdate the `selected_rows` with the `newRowSelections()`. If the `ctrlKey` and\n`metaKey` aren't pressed then our user isn't multi-selecting, and we should\nclear the prior selections. Finally, we'll call `draw()` on the `table` ensuring\nthe new selection shows.\n\n### When creating `newRowSelections()`\n\nIf the `metaKey` or `ctrlKey` are pressed, we'll consider the interaction to be\n`inMultiSelectMode` and add or remove selections - otherwise, we'll return a new\nselection that replaces the entire collection.\n\nWe've also defined a helper function, `targetRowSelection()`, .. with the help\nof our `DataListener`, it takes a `MetaData` `object` and generates a\n`RowSelection` updating the `y0` to the `meta.y` and the `y1` to the\n`lastIndexOfRowGroup()` if this selection represents a group of rows -\neffectively making it a range selection. We'll save the implementation of\n`lastIndexOfRowGroup()` for later.\n\n```javascript\nconst newRowSelections = (table, meta, event, dl) => {\n    const inMultiSelectMode = event.ctrlKey || event.metaKey;\n    const targetSelection = targetRowSelection(meta, dl);\n\n    if (inMultiSelectMode) {\n        return newMultiSelectRow(table, targetSelection, dl);\n    } else {\n        return newSingleSelectRow(table, targetSelection, dl);\n    }\n};\n\nconst targetRowSelection = (meta, dl) => {\n    const target = { ...meta };\n    target.y0 = meta.y;\n\n    const isRowGroup =\n        typeof meta.row_header_x !== \"undefined\" &&\n        meta.row_header_x !== meta.row_header.length - 1;\n    if (isRowGroup) {\n        target.y1 = lastIndexOfRowGroup(dl, meta);\n    } else {\n        target.y1 = meta.y;\n    }\n\n    return target;\n};\n```\n\nIn `newSingleSelectRow()`, we'll need to define three different behaviors -\nsingle selection, deselection and range selection.\n\nMost spreadsheets will allow the end user to select a range of rows, so we'll\nconsider selections made with the `shiftKey` a range selection. Without the\n`shiftKey`, we'll `return` the single row selection or deselect it if a matching\nselection already exists by returning empty.\n\n```javascript\nconst newSingleSelectRow = (table, targetSelection, dl) => {\n    const matches = matchingRowSelections(table, targetSelection);\n\n    if (matches.length > 0) {\n        return [];\n    } else {\n        if (event.shiftKey) {\n            return [createRowRangeSelection(table, targetSelection, dl)];\n        } else {\n            return [targetSelection];\n        }\n    }\n};\n```\n\nWe'll need a couple helper functions, one that returns the\n`matchingRowSelections()` by iterating throught the `selected_rows` and\nreturning all `RowSelection`s who's rows intersect...\n\n```javascript\nconst matchingRowSelections = (table, { y, y0, y1 }) => {\n    const _y = y !== undefined ? y : Math.min(y0, y1);\n    return table[PRIVATE].selected_rows.filter((s) => s.y0 <= _y && _y <= s.y1);\n};\n```\n\n... and a way to create a `RowSelection` that represents a range selection by\nlooking at the `lastSelection` in `selected_rows`. If there is a\n`lastSelection`, we'll update the given `rowSelection` with the `min()` `y0` and\n`max` `y1` to ensure the correct range selecting top to bottom as well as bottom\nto top. `createRowRangeSelection()` will also ensure that the resulting\n`RowSelection` represents a range over a uniform level of selections. If one of\nthe selections is a Group and the other is a Row we should select the\nappropriate `row_header_x`.\n\n```javascript\nconst createRowRangeSelection = (table, rowSelection, dl) => {\n    const selectedRows = table[PRIVATE].selected_rows;\n    const lastSelection = selectedRows[selectedRows.length - 1];\n\n    if (lastSelection) {\n        const y0 = Math.min(\n            rowSelection.y0,\n            lastSelection.y0,\n            rowSelection.y1,\n            lastSelection.y1\n        );\n        const y1 = Math.max(\n            rowSelection.y0,\n            lastSelection.y0,\n            rowSelection.y1,\n            lastSelection.y1\n        );\n        const row_header_x = Math.min(\n            rowSelection.row_header_x,\n            lastSelection.row_header_x\n        );\n        rowSelection.y0 = y0;\n        rowSelection.y1 = y1;\n    }\n    return rowSelection;\n};\n```\n\nOur multi-select implementation is slightly more complicated when we find a\nmatch. If the user clicks on an already selected row header `inMultiSelectMode`\nwe want to simply remove the selection, but if the selection is a range, we'll\nneed to split the range into two row selections, removing the `targetSelection`.\n\n```javascript\nconst newMultiSelectRow = (table, targetSelection, dl) => {\n    const matches = matchingRowSelections(table, targetSelection);\n\n    if (matches.length > 0) {\n        let newSelections = rejectMatchingRowSelections(table, targetSelection);\n        return splitRowRangeMatches(newSelections, targetSelection);\n    } else {\n        if (event.shiftKey) {\n            return table[PRIVATE].selected_rows.concat(\n                createRowRangeSelection(table, targetSelection, dl)\n            );\n        } else {\n            return table[PRIVATE].selected_rows.concat(targetSelection);\n        }\n    }\n};\n```\n\nWe can write a complement to our `matchingRowSelections()` that returns all the\n`RowSelection`s that don't match the input's row.\n\n```javascript\nconst rejectMatchingRowSelections = (table, { y, y0, y1 }) => {\n    const _y = y ? y : Math.min(y0, y1);\n    return table[PRIVATE].selected_rows.filter(\n        ({ y0, y1 }) => !(y0 == _y && _y == y1)\n    );\n};\n```\n\nAnd we'll need a way to split all the matching range `RowSelection`s. This one's\na bit dense, but let's walk through it. We iterate through the `selections` and\nfind matches based on the overlap of `y0`s and `y1`s similar to our\n`matchingRowSelections()` helper. If it's a matching range (ie. the `y0` and\n`y1` aren't equal) then we return potentially two `RowSelections` - the part of\nthe range up to the `rowSelection` passed in and the part after. Our use of\n`flatMap()` ensures that the result is a one-dimensional `Array` of\n`RowSelections`.\n\n```javascript\nconst splitRowRangeMatches = (selections, rowSelection) => {\n    return selections.flatMap((s) => {\n        const row_header_x = Math.max(\n            rowSelection.row_header_x,\n            s.row_header_x\n        );\n        const matchesRangeSelection =\n            s.y0 <= rowSelection.y0 && rowSelection.y1 <= s.y1 && s.y0 !== s.y1;\n\n        if (matchesRangeSelection) {\n            const firstSplit = {\n                row_header_x,\n                y0: s.y0,\n                y1: rowSelection.y0 - 1,\n                row_header: s.row_header,\n            };\n            const secondSplit = {\n                row_header_x,\n                y0: rowSelection.y1 + 1,\n                y1: s.y1,\n                row_header: s.row_header,\n            };\n            return [firstSplit, secondSplit].filter((s) => s.y0 <= s.y1);\n        } else {\n            return s;\n        }\n    });\n};\n```\n\n### `lastIndexOfRowGroup()`\n\nWe need a way to scan the `row_headers` present in the `DataListener` and find\nthe end, _`y`_, of the group if a group of rows is selected. We've chosen to\nchunk our scan preventing a crash in the event that the `DataModel` represents\n`two_billion_rows`.\n\n```javascript\nconst lastIndexOfRowGroup = (dl, { row_header_x, value, y }) => {\n    const { num_rows } = dl(0, 0, 1, 1);\n    let idx;\n    const chunk = 100;\n    let y0 = y;\n    let y1 = Math.min(y + chunk, num_rows);\n    do {\n        const rowHeaderSlice = dl(0, y0, 0, y1).row_headers.map((h, idx) => [\n            y + idx,\n            h,\n        ]);\n        const result = rowHeaderSlice.find(\n            ([_, row_headers]) => row_headers[row_header_x] !== value\n        );\n        if (result) {\n            [idx] = result;\n        } else {\n            y0 = Math.min(y0 + chunk, num_rows);\n            y1 = Math.min(y1 + chunk, num_rows);\n        }\n    } while (idx === undefined && y1 < num_rows);\n    return idx === undefined ? num_rows : idx - 1;\n};\n```\n\n## `StyleListener`\n\nAs our `<regular-table>` is re-rendered, we will want to ensure that our\nselection is styled correctly by reapplying our `MOUSE_SELECTED_ROW_CLASS` class\nto the correct `td`s and `th`s.\n\nFirst we'll `reapplyRowTHSelection()` and have that `return` the selected `y`s,\nthen we'll use the `y`s to `reapplyRowTDSelection()`.\n\n```javascript\nconst addRowSelectionStyleListener = (table, dl, className) => {\n    table.addStyleListener(() => {\n        const ys = reapplyRowTHSelection(table, dl, className);\n\n        if (ys.length > 0) {\n            reapplyRowTDSelection(table, ys, className);\n        } else {\n            reapplyRowSelection(table, dl, className);\n        }\n    });\n};\n\nconst reapplyRowSelection = (table, dl, className) => {\n    const elements = table.querySelectorAll(\"tbody td\");\n\n    if (elements.length > 0) {\n        for (const el of elements) {\n            const meta = table.getMeta(el);\n            const matches = matchingRowSelections(table, meta);\n            if (matches.length > 0) {\n                el.classList.add(className);\n            } else {\n                el.classList.remove(className);\n            }\n        }\n    }\n};\n```\n\nIn order to reapply row selection to our `th`s, we'll need to find all of them\nin our `table` and iterate over the collection - adding or removing the\n`MOUSE_SELECTED_ROW_CLASS` based on whether or not the `th` is selected.\n\nIf the `th` is part of the selection, we'll add the class to its `classlist` and\n`push()` its `y` into the `selectedYs` returned.\n\nOur `isRowHeaderSelected()` function needs to scan the `visibleRowHeaders` to\nselect groups and ranges, so as an optimization, we've calculated that once to\nreuse for each of the `elements`. It's a collection of the `row_headers` for the\nrange of the viewport based on the first `MetaData` in the collection mapped to\ninclude an index offset by the `y0` or viewport origin.\n\n```javascript\nconst reapplyRowTHSelection = (table, dl, className) => {\n    const elements = table.querySelectorAll(\"tbody th\");\n    let selectedYs = [];\n\n    if (elements.length > 0) {\n        const meta0 = table.getMeta(elements[0]);\n        const visibleRowHeaders = dl(\n            0,\n            meta0.y0,\n            0,\n            meta0.y1 + 1\n        ).row_headers.map((h, idx) => [meta0.y0 + idx, h]);\n        for (const el of elements) {\n            const meta = table.getMeta(el);\n\n            if (isRowHeaderSelected(table, meta, visibleRowHeaders)) {\n                selectedYs.push(meta.y);\n                el.classList.add(className);\n            } else {\n                el.classList.remove(className);\n            }\n        }\n    }\n    return selectedYs;\n};\n```\n\nThe implementation of `isRowHeaderSelected()` can be broken down into two\nchecks.\n\nUsing our `matchingRowSelections()` helper, we find all of the `matches` and\ncheck for a direct match - when the `row_header_x` values match.\n\nIt's a bit more complex to check if the `th` is a member of a group selection.\nIn `isGroupMatch()`, we'll make use of our `visibleRowHeaders` collection, a\ntwo-dimensional `Array` of the form `[index, [\"Group 0\", \"Row 0\"]]`. First we'll\n`filter()` the row headers to those that intersect with the `selection`'s range,\nthen we'll extract the `row_header` that matches our `selection`'s\n`row_header_x`. The resulting `matchingGroupValues` will look something like\n`[\"Group 0\", \"Group 10\", ...]`. Next, we find the indexes of each value that\nmatches our `selection` and compare.\n\n```javascript\nconst isRowHeaderSelected = (table, meta, visibleRowHeaders) => {\n    const matches = matchingRowSelections(table, meta);\n\n    const isGroupMatch = () => {\n        return table[PRIVATE].selected_rows.find((selection) => {\n            const matchingGroupValues = visibleRowHeaders\n                .filter(([idx]) => selection.y0 <= idx && idx <= selection.y1)\n                .map(([idx, row_headers]) => idx);\n            return (\n                selection.row_header_x < meta.row_header_x &&\n                matchingGroupValues.indexOf(meta.y) !== -1\n            );\n        });\n    };\n    const isDirectMatch = () =>\n        !!matches.find((m) => m.row_header_x === meta.row_header_x);\n\n    return isDirectMatch() || isGroupMatch();\n};\n```\n\nBy comparison, reapplying the row `td` selection is simple. We check the\n`MetaData` from `getMeta()` and if its `y` is in the `ys` passed in we `add()`\nthe `MOUSE_SELECTED_ROW_CLASS`.\n\n```javascript\nconst reapplyRowTDSelection = (table, ys, className) => {\n    const elements = table.querySelectorAll(\"tbody td\");\n\n    for (const el of elements) {\n        const meta = table.getMeta(el);\n\n        if (ys.indexOf(meta.y) !== -1) {\n            el.classList.add(className);\n        } else {\n            el.classList.remove(className);\n        }\n    }\n};\n```\n\n## Styling\n\nLet's style our `mouse-selected-row` - in this example we'll use a light yellow.\n\n```css\nregular-table tbody tr td.mouse-selected-row,\nregular-table tr th.mouse-selected-row {\n    background-color: #2771a8;\n    color: white;\n}\n```\n\nAnd we can disable the default `user-select`.\n\n```css\nregular-table tbody tr th,\nregular-table tbody tr td {\n    user-select: none;\n}\n```\n\n## Appendix (Dependencies)\n\nNone of this would work without our libraries below.\n\n```html\n<script src=\"/dist/umd/regular-table.js\"></script>\n<link rel=\"stylesheet\" href=\"/dist/css/material.css\" />\n```\n\n```block\nlicense: apache-2.0\n```\n\n"]}