{"version":3,"sources":["column_mouse_selection.md"],"names":[],"mappings":"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","sourcesContent":["# Mouse Column Selection\n\nMouse column selection shares a similar behavior to mouse row selection. We\nexpect that when we `\"click\"` on the column header then the column shows as\nselected. In this example, the columns are grouped as well, and when the group\nis selected then columns under the group should show as selected too. We'll also\nallow the user to make multiple selections when holding down the `ctrl` or\n`metaKey`.\n\nThe bulk of the logic belongs in a `\"click\"` `EventListener`, so our\n`addColumnMouseSelection()` should take a `table` and add a `clickListener()`.\n\nIt will also be responsible for adding the `StyleListener` to ensure the\nselection shows correctly as the `table` scrolls.\n\n# API\n\n```html\n<regular-table id=\"example_table\"></regular-table>\n```\n\nOn `\"load\"`, we'll handle wiring our behavior up by generating and setting the\n`DataListener` and passing it to `addColumnMouseSelection()` along with our\n`table`. Finally, we'll make the initial `draw()` call.\n\n```html\n<script type=\"module\">\n    import { addColumnMouseSelection } from \"./column_mouse_selection.js\";\n    import { dataListener } from \"/dist/examples/two_billion_rows.js\";\n\n    window.addEventListener(\"load\", () => {\n        const dl = dataListener(200, 50);\n        example_table.setDataListener(dl);\n        addColumnMouseSelection(example_table, dl, {\n            selected: [\n                {\n                    column_header: [\"Group 0\", \"Column 6\"],\n                    column_header_y: 1,\n                    x0: 6,\n                    x1: 6,\n                },\n                {\n                    column_header: [\"Group 0\", \"Column 8\"],\n                    column_header_y: 1,\n                    x0: 8,\n                    x1: 8,\n                },\n                {\n                    column_header: [\"Group 0\", \"Column 9\"],\n                    column_header_y: 1,\n                    x0: 8,\n                    x1: 9,\n                },\n            ],\n        });\n        example_table.draw();\n    });\n</script>\n```\n\n## `addColumnMouseSelection()`\n\nSimilar to `addRowMouseSelection()`, we expect that when we `\"click\"` on the\ncolumn header or the grouped column header then the column shows as selected.\n\n```javascript\nconst PRIVATE = Symbol(\"Column Mouse Selection\");\nconst MOUSE_SELECTED_COLUMN_CLASS = \"mouse-selected-column\";\n\nexport const addColumnMouseSelection = (\n    table,\n    dl,\n    { className = MOUSE_SELECTED_COLUMN_CLASS, selected = [] } = {}\n) => {\n    table[PRIVATE] = { selected_columns: selected };\n\n    const clickListener = (event) => {\n        let meta = table.getMeta(event.target);\n\n        if (!meta && event.path) {\n            const th = event.path.reverse().find((el) => table.getMeta(el));\n            meta = table.getMeta(th);\n        }\n\n        const headerWasClicked =\n            meta && typeof meta.column_header_y !== \"undefined\";\n\n        if (headerWasClicked) {\n            table[PRIVATE] = {\n                selected_columns: newColumnHeaderSelections(\n                    table,\n                    meta,\n                    event,\n                    dl\n                ),\n            };\n        } else if (!event.ctrlKey && !event.metaKey) {\n            table[PRIVATE] = { selected_columns: [] };\n        }\n        table.draw();\n    };\n\n    table.addEventListener(\"click\", clickListener);\n    addColumnSelectionStyleListener(table, dl, className);\n    return table;\n};\n```\n\nWe will keep a `ColumnSelection` object in our `table` that resembles the\n`RowSelection` object in `row_mouse_selection`.\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| [x0] | `number` | The `x` index that begins the selection. |\n| [x1] | `number` | The `x` index that ends the selection. |\n| [column_header_y] | `number` | The `y` of this header's `row_header`. |\n| [column_header] | <code>Array.<object></code> | The header selections. |\n\nThe logic of our `\"click\"` `EventListener` only differs in the `MetaData`\nattributes we need in order to produce the `newColumnHeaderSelections()`.\nThroughout this example we'll be focusing on the `x` indexes and\n`column_header`s in place of the `y` and `row_header`s.\n\n### When creating `newColumnHeaderSelections()`\n\nWe will check the `meta` and `ctrlKey` to determine the selection mode, and our\nmethod of generating a `targetColumnSelection()` will grab the attributes from\nthe `MetaData` appropriate for generating our `ColumnSelection`.\n\n```javascript\nconst newColumnHeaderSelections = (table, meta, event, dl) => {\n    const inMultiSelectMode = event.ctrlKey || event.metaKey;\n    const targetSelection = targetColumnSelection(meta, dl);\n\n    if (inMultiSelectMode) {\n        return newMultiSelectColumnHeaders(table, targetSelection, dl);\n    } else {\n        return newSingleSelectColumnHeaders(table, targetSelection, dl);\n    }\n};\n\nconst targetColumnSelection = (meta, dl) => {\n    const target = { ...meta };\n    target.x0 = meta.x;\n\n    const isColumnGroup =\n        meta.column_header_y !== meta.column_header.length - 1 &&\n        meta.x !== undefined;\n    if (isColumnGroup) {\n        target.x1 = lastIndexOfColumnGroup(dl, meta);\n    } else {\n        target.x1 = meta.x;\n    }\n\n    return target;\n};\n```\n\nWe'll create a single range selection if the `shiftKey` is pressed otherwise a\nsingle column is selected.\n\n```javascript\nconst newSingleSelectColumnHeaders = (table, targetSelection, dl) => {\n    const matches = matchingColumnSelections(table, targetSelection);\n\n    if (matches.length > 0) {\n        return [];\n    } else {\n        if (event.shiftKey) {\n            return [createColumnRangeSelection(table, targetSelection, dl)];\n        } else {\n            return [targetSelection];\n        }\n    }\n};\n```\n\nIf the selection was already made based on our `matchingColumnSelections()`, we\nwill instead clear the `selected_columns` by returning an empty `Array`.\n\n```javascript\nconst matchingColumnSelections = (table, { x, x0, x1 }) => {\n    const _x = x !== undefined ? x : Math.min(x0, x1);\n    return table[PRIVATE].selected_columns.filter(\n        (s) => s.x0 <= _x && _x <= s.x1\n    );\n};\n```\n\nCreating a column range selection closely mirrors `createRowRangeSelection()` in\nour `row_mouse_selection` example.\n\n```javascript\nconst createColumnRangeSelection = (table, columnSelection, dl) => {\n    const selectedColumns = table[PRIVATE].selected_columns;\n    const lastSelection = selectedColumns[selectedColumns.length - 1];\n    if (lastSelection) {\n        const x0 = Math.min(\n            columnSelection.x0,\n            lastSelection.x0,\n            columnSelection.x1,\n            lastSelection.x1\n        );\n        const x1 = Math.max(\n            columnSelection.x0,\n            lastSelection.x0,\n            columnSelection.x1,\n            lastSelection.x1\n        );\n        const column_header_y = Math.min(\n            columnSelection.column_header_y,\n            lastSelection.column_header_y\n        );\n        columnSelection.x0 = x0;\n        columnSelection.x1 = x1;\n    }\n    return columnSelection;\n};\n```\n\n... as does our logic for multi-select.\n\n```javascript\nconst newMultiSelectColumnHeaders = (table, targetSelection, dl) => {\n    const matches = matchingColumnSelections(table, targetSelection);\n\n    if (matches.length > 0) {\n        let newSelections = rejectMatchingColumnSelections(\n            table,\n            targetSelection\n        );\n        return splitColumnRangeMatches(newSelections, targetSelection);\n    } else {\n        if (event.shiftKey) {\n            return table[PRIVATE].selected_columns.concat(\n                createColumnRangeSelection(table, targetSelection, dl)\n            );\n        } else {\n            return table[PRIVATE].selected_columns.concat(targetSelection);\n        }\n    }\n};\n\nconst rejectMatchingColumnSelections = (table, { x, x0, x1 }) => {\n    const _x = x ? x : Math.min(x0, x1);\n    return table[PRIVATE].selected_columns.filter(\n        ({ x0, x1 }) => !(x0 == _x && _x == x1)\n    );\n};\n\nconst splitColumnRangeMatches = (selections, columnSelection) => {\n    return selections.flatMap((s) => {\n        const column_header_y = Math.max(\n            columnSelection.column_header_y,\n            s.column_header_y\n        );\n        const matchesRangeSelection =\n            s.x0 <= columnSelection.x0 &&\n            columnSelection.x1 <= s.x1 &&\n            s.x0 !== s.x1;\n\n        if (matchesRangeSelection) {\n            const firstSplit = {\n                column_header_y,\n                x0: s.x0,\n                x1: columnSelection.x0 - 1,\n                column_header: s.column_header,\n            };\n            const secondSplit = {\n                column_header_y,\n                x0: columnSelection.x1 + 1,\n                x1: s.x1,\n                column_header: s.column_header,\n            };\n            return [firstSplit, secondSplit].filter((s) => s.x0 <= s.x1);\n        } else {\n            return s;\n        }\n    });\n};\n```\n\n## `StyleListener`\n\nWe need to use a `StyleListener` to make our selection re-render on `draw()`, so\nwe'll check each `td` and `th` in our `table` and update their `classList`. Our\nfunction to update the `th`s will report the `x`s marked as selected for reuse\nin `reapplyColumnTDSelection()`.\n\n```javascript\nconst addColumnSelectionStyleListener = (table, dl, className) => {\n    table.addStyleListener(() => {\n        const xs = reapplyColumnTHSelection(table, dl, className);\n        reapplyColumnTDSelection(table, xs, className);\n    });\n};\n```\n\nOur `reapplyColumnTHSelection()` and `reapplyColumnTDSelection()` functions are\ncomplicated but symmetric to our `reapplyRowTHSelection()` and\n`reapplyRowTDSelection()` definitions.\n\n```javascript\nconst reapplyColumnTHSelection = (table, dl, className) => {\n    const elements = table.querySelectorAll(\"thead th\");\n    let selectedXs = [];\n\n    if (elements.length > 0) {\n        const tds = table.querySelectorAll(\"tbody td\");\n        const tdMeta1 = table.getMeta(tds[0]);\n        const meta0 = table.getMeta(elements[0]);\n\n        const visibleHeaders = dl(\n            tdMeta1.x0,\n            0,\n            tdMeta1.x1 + 1,\n            0\n        ).column_headers.map((h, idx) => [meta0.x0 + idx, h]);\n        for (const el of elements) {\n            const meta = table.getMeta(el);\n\n            if (isColumnHeaderSelected(table, meta, visibleHeaders)) {\n                selectedXs.push(meta.x);\n                el.classList.add(className);\n            } else {\n                el.classList.remove(className);\n            }\n        }\n    }\n    return selectedXs;\n};\n\nconst isColumnHeaderSelected = (table, meta, visibleHeaders) => {\n    const matches = matchingColumnSelections(table, meta);\n\n    const isGroupMatch = () => {\n        return table[PRIVATE].selected_columns.find((selection) => {\n            const matchingGroupValues = visibleHeaders\n                .filter(([idx]) => selection.x0 <= idx && idx <= selection.x1)\n                .map(([idx, column_headers]) => idx);\n            return (\n                selection.column_header_y < meta.column_header_y &&\n                matchingGroupValues.indexOf(meta.x) !== -1\n            );\n        });\n    };\n    const isDirectMatch = () =>\n        !!matches.find((m) => m.column_header_y === meta.column_header_y);\n\n    return isDirectMatch() || isGroupMatch();\n};\n\nconst reapplyColumnTDSelection = (table, xs, className) => {\n    const elements = table.querySelectorAll(\"tbody td\");\n\n    for (const el of elements) {\n        const meta = table.getMeta(el);\n\n        if (xs.indexOf(meta.x) !== -1) {\n            el.classList.add(className);\n        } else {\n            el.classList.remove(className);\n        }\n    }\n};\n```\n\n### `lastIndexOfColumnGroup()`\n\nWe need to scan the `DataListener` to find the final index of a group selection\nto ensure it's properly styled. For a more in depth explanation, see\n`lastIndexOfRowGroup()`.\n\n```javascript\nconst lastIndexOfColumnGroup = (dl, { column_header_y, value, x }) => {\n    const { num_columns } = dl(0, 0, 1, 1);\n    let idx;\n    const chunk = 100;\n    let x0 = x;\n    let x1 = Math.min(x + chunk, num_columns);\n    do {\n        const columnHeaderSlice = dl(\n            x0,\n            0,\n            x1,\n            0\n        ).column_headers.map((h, idx) => [x + idx, h]);\n        const result = columnHeaderSlice.find(\n            ([_, column_headers]) => column_headers[column_header_y] !== value\n        );\n        if (result) {\n            [idx] = result;\n        } else {\n            x0 = Math.min(x0 + chunk, num_columns);\n            x1 = Math.min(x1 + chunk, num_columns);\n        }\n    } while (idx === undefined && x1 < num_columns);\n    return idx === undefined ? num_columns : idx - 1;\n};\n```\n\n## Styling\n\nOur `mouse-selected-column` will need some style to make it visually distinct.\n\n```css\nregular-table tbody tr td.mouse-selected-column,\nregular-table tr th.mouse-selected-column {\n    background-color: #2771a8;\n    color: white;\n}\n```\n\nAnd we similarly disable the default `user-select` here.\n\n```css\nregular-table thead tr th,\nregular-table tbody tr td {\n    user-select: none;\n}\n```\n\n## Appendix (Dependencies)\n\nOf course, we'll pull in our libraries.\n\n```html\n<script src=\"/dist/umd/regular-table.js\"></script>\n<link rel=\"stylesheet\" href=\"/dist/css/material.css\" />\n```\n\n```block\nlicense: apache-2.0\n```\n\n"]}