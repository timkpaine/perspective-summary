{"version":3,"file":"regular-table.js","sources":["../../src/js/constants.js","../../src/js/utils.js","../../src/js/scroll_panel.js","../../src/js/events.js","../../src/js/view_model.js","../../src/js/thead.js","../../src/js/tbody.js","../../src/js/table.js","../../src/js/index.js"],"sourcesContent":["/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\n// Singleton `WeakMap`s to store metadata for td/th elements, as well as the\n// datagrids themselves for each `<perspective-viewer>`\nexport const METADATA_MAP = new WeakMap();\n\n// Output runtime debug info like FPS.\nexport const DEBUG = true;\n\n// The largest size virtual <div> in (px) that Chrome can support without\n// glitching.\nconst isFirefox = navigator.userAgent.toLowerCase().indexOf(\"firefox\") > -1;\nexport const BROWSER_MAX_HEIGHT = isFirefox ? 5000000 : 10000000;\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\n/******************************************************************************\n *\n * Profling\n *\n */\n\nlet AVG = 0,\n    TOTAL = 0,\n    START = performance.now();\n\nexport function get_draw_fps() {\n    const now = performance.now();\n    const elapsed = now - START;\n    const avg = AVG;\n    const real_fps = (TOTAL * 1000) / elapsed;\n    const virtual_fps = 1000 / avg;\n    const num_frames = TOTAL;\n    AVG = 0;\n    TOTAL = 0;\n    START = now;\n    return {avg, real_fps, virtual_fps, num_frames, elapsed};\n}\n\nexport function log_perf(x) {\n    AVG = (AVG * TOTAL + x) / (TOTAL + 1);\n    TOTAL += 1;\n}\n\n/******************************************************************************\n *\n * Utils\n *\n */\n\n/**\n * A class method decorate for memoizing method results.  Only works on one\n * arg.\n */\nexport function memoize(_target, _property, descriptor) {\n    const cache = new Map();\n    const func = descriptor.value;\n    descriptor.value = new_func;\n    return descriptor;\n    function new_func(arg) {\n        if (cache.has(arg)) {\n            return cache.get(arg);\n        } else {\n            const res = func.call(this, arg);\n            cache.set(arg, res);\n            return res;\n        }\n    }\n}\n\n/**\n * Identical to a non-tagger template literal, this is only used to indicate to\n * babel that this string should be HTML-minified on production builds.\n */\nexport const html = (strings, ...args) =>\n    strings\n        .map((str, i) => [str, args[i]])\n        .flat()\n        .filter((a) => !!a)\n        .join(\"\");\n\nconst invertPromise = () => {\n    let _resolve;\n    const promise = new Promise((resolve) => {\n        _resolve = resolve;\n    });\n    promise.resolve = _resolve;\n    return promise;\n};\n\nexport function throttlePromise(target, property, descriptor) {\n    const f = descriptor.value;\n    const lock_symbol = Symbol(\"regular-table throttle lock\");\n    descriptor.value = async function (...args) {\n        if (this[lock_symbol] !== undefined) {\n            await this[lock_symbol];\n            if (this[lock_symbol] !== undefined) {\n                await this[lock_symbol];\n                return;\n            }\n        }\n        this[lock_symbol] = invertPromise();\n        let result;\n        try {\n            result = await f.call(this, ...args);\n        } finally {\n            const l = this[lock_symbol];\n            this[lock_symbol] = undefined;\n            l.resolve();\n        }\n        return result;\n    };\n    descriptor.value.flush = async function () {\n        await new Promise(requestAnimationFrame);\n        return await this[lock_symbol];\n    };\n    return descriptor;\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {log_perf, html, throttlePromise} from \"./utils\";\nimport {DEBUG, BROWSER_MAX_HEIGHT} from \"./constants\";\n\nimport container_css from \"../less/container.less\";\nimport sub_cell_offsets from \"../less/sub-cell-offsets.less\";\n\n/**\n * Handles the virtual scroll pane, as well as the double buffering\n * of the underlying <table>. This DOM structure looks a little like\n * this:\n *\n *     +------------------------+      <- regular-table\n *     | +----------------------|------<- div.rt-virtual-panel\n *     | | +------------------+ |      <- div.rt-scroll-table-clip\n *     | | | +----------------|-|--+   <- table             |\n *     | | | | 1  A  Alabama  | |  |                        |\n *     | | | | 2  B  Arizona  | |  |                        |\n *     | | | | 3  C  Arkansas | |  |                        |\n *     | | | | 4  D  Californi| |  |                        |\n *     | | | | 5  E  Colorado | |  |                        |\n *     | | +------------------+ |  |                        |\n *     +------------------------+  |                        |\n *       |   | 8  H  District of C |                        |\n *       |   +---------------------+                        |\n *       |                                                  |\n *       |                                                  |\n *       |                                                  |\n *       |                                                  |\n *       |                                                  |\n *       +--------------------------------------------------+\n *\n * `overflow: auto` is applied to `.rt-scroll-container`, and `.rt-virtual-pane`\n * is sized to match the estimated \"virtual\" size of the `table`;  estimated,\n * because it's true size can't be known until all columns dimensions are known,\n * which may be deferred in the case of auto-sized tables.\n *\n * Double buffering can be enabled on \"column scroll\", \"row scroll\" and/or\n * \"column schema change\".  When enabled and a redraw is requested for the case,\n * the existing table is cloned with `cloneNode()` and swapped with the real\n * `table`, which is then updated offscreen and swapped back in.  While this is\n * much slower to render, it prevents draw-in.\n *\n * @class RegularVirtualTableViewModel\n */\nexport class RegularVirtualTableViewModel extends HTMLElement {\n    /**\n     * Create the DOM for this `shadowRoot`.\n     *\n     * TODO deprecated\n     * `MATERIAL_STYLE` is needed both here, and in the document `<head>`, due\n     * to double buffering, which may read incorrect position/size values as the\n     * double buffered `<table>` is rendered in the shadow DOM before being\n     * swapped in.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     */\n    create_shadow_dom() {\n        this.attachShadow({mode: \"open\"});\n        const slot = `<slot></slot>`;\n        this.shadowRoot.innerHTML = html`\n            <style>\n                ${container_css}\n            </style>\n            <style>\n                ${sub_cell_offsets}\n            </style>\n            <div class=\"rt-virtual-panel\"></div>\n            <div class=\"rt-scroll-table-clip\">\n                ${slot}\n            </div>\n        `;\n\n        const [, style, virtual_panel, table_clip] = this.shadowRoot.children;\n        this._sub_cell_style = style;\n        this._table_clip = table_clip;\n        this._virtual_panel = virtual_panel;\n        this._setup_virtual_scroll();\n    }\n\n    _setup_virtual_scroll() {\n        if (this._table_clip) {\n            if (this._virtual_mode === \"both\" || this._virtual_mode === \"vertical\") {\n                this._table_clip.style.top = \"0px\";\n            } else {\n                this._table_clip.style.removeProperty(\"top\");\n            }\n\n            if (this._virtual_mode === \"both\" || this._virtual_mode === \"horizontal\") {\n                this._table_clip.style.left = \"0px\";\n            } else {\n                this._table_clip.style.removeProperty(\"left\");\n            }\n\n            if (this._virtual_mode !== \"both\") {\n                this._table_clip.style.contain = \"none\";\n            } else {\n                this._table_clip.style.removeProperty(\"contain\");\n            }\n        }\n    }\n\n    /**\n     * Calculates the `viewport` argument for perspective's `to_columns` method.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} nrows\n     * @returns\n     */\n    _calculate_viewport(nrows, num_columns) {\n        const {start_row, end_row} = this._calculate_row_range(nrows);\n        const {start_col, end_col} = this._calculate_column_range(num_columns);\n        this._nrows = nrows;\n        return {start_col, end_col, start_row, end_row};\n    }\n\n    /**\n     * Calculate `start_row` and `end_row` for the viewport.  We do this by\n     * first calculating `total_scroll_height`, the px height of the\n     * scrollable page, from the `_virtual_panel.offsetHeight`.\n     *\n     *    0px +------------+-------------+  - virtual_panel.offsetHeight\n     *        |            |  .          |  . 600px\n     *        |  viewport  |  .          |  .\n     *        |            |  .          |  .\n     *  200px +------------+  - height   |  .  - total_scroll_height\n     *        |                 200px    |  .  . 400px\n     *        |                          |  .  .\n     *        |                          |  .  .\n     *        |                          |  .  .\n     *        |                          |  .  .\n     *  600px +--------------------------+  -  -\n     *\n     *  `percent_scroll` can be calculated from this value and `scrollTop`,\n     *  which we can then apply to the new calculated height to preserve scroll\n     *  position when the height has changed since previous render.\n     *\n     *    0px +--------------------------+  -\n     *        |                          |  .\n     *        |                          |  .\n     *        |                          |  . scrollable area\n     *  300px +------------+             |  .\n     *        |            |             |  .\n     *  - - - |  viewport  | - - - - - - |  - total_scroll_height\n     *        |            |             |    400px\n     *  500px +------------+             |\n     *        |                          |\n     *  600px +--------------------------+\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} nrows\n     * @returns\n     */\n    _calculate_row_range(nrows) {\n        const {height} = this._container_size;\n        const row_height = this._column_sizes.row_height || 19;\n        const header_levels = this._view_cache.config.column_pivots.length;\n        const total_scroll_height = Math.max(1, this._virtual_panel.offsetHeight - this.clientHeight);\n        const percent_scroll = Math.max(Math.ceil(this.scrollTop), 0) / total_scroll_height;\n        const virtual_panel_row_height = height / row_height - header_levels;\n        const relative_nrows = nrows || 0;\n        const scroll_rows = Math.max(0, Math.ceil(relative_nrows - virtual_panel_row_height));\n        const start_row = scroll_rows * percent_scroll;\n        const end_row = Math.max(0, Math.min(start_row + virtual_panel_row_height, nrows));\n        return {start_row, end_row};\n    }\n\n    _calc_start_column() {\n        const scroll_index_offset = this._view_cache.config.row_pivots.length;\n        let start_col = 0;\n        let offset_width = 0;\n        let diff = 0;\n        while (offset_width < this.scrollLeft) {\n            const new_val = this._column_sizes.indices[start_col + scroll_index_offset];\n            diff = this.scrollLeft - offset_width;\n            start_col += 1;\n            offset_width += new_val !== undefined ? new_val : 60;\n        }\n\n        start_col += diff / (this._column_sizes.indices[start_col + scroll_index_offset - 1] || 60);\n        return Math.max(0, start_col - 1);\n    }\n\n    /**\n     * Calculates `start_col` and `end_col` for the viewport - most of the\n     * details of which are actually calculated in `_max_column`, the equivalent\n     * of `total_scroll_height` from `_calculate_row_range`.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @returns\n     */\n    _calculate_column_range(num_columns) {\n        if (this._virtual_mode === \"none\" || this._virtual_mode === \"vertical\") {\n            return {start_col: 0, end_col: Infinity};\n        } else {\n            const start_col = this._calc_start_column();\n            const vis_cols = this.table_model.num_columns() || Math.min(num_columns, Math.ceil(this._container_size.width / 60));\n            let end_col = start_col + vis_cols + 1;\n            return {start_col, end_col};\n        }\n    }\n\n    /**\n     * Calculates the minimum possible starting column index for which the last\n     * column is completely visible (e.g. not occluded by the container clip).\n     * This is assumed to be the # of columns until the column widths are\n     * calculated as they are scrolled into view by the user, which requires\n     * special synchronization with _update_virtual_panel_width`\n     * as the scrollable width will change as the user scrolls left to right.\n     *\n     * Once `_column_sizes.indices` has enough column widths populated from\n     * user scrolling, it calulates the cumulative sum of column widths from\n     * last visible column backwards, until the sum is larger than the viewport\n     * px width, which is 1 below the max scroll column\n     *\n     *               width = 290   = 210     = 100    = 0\n     *   0px               V       V         V        500px\n     *   +-----------------+-------+---------+--------+\n     *   | ..ol B) (Col C) | Col D | Col E   | Col F  |\n     *   |                 | 80px  | 110px   | 100px  |\n     *   |                 |       |         |        |\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @returns\n     */\n    _max_scroll_column(num_columns) {\n        let width = 0;\n        if (this._view_cache.config.row_pivots.length > 0) {\n            for (const w of this._column_sizes.indices.slice(0, this._view_cache.config.row_pivots.length)) {\n                width += w;\n            }\n        }\n        let scroll_index_offset = this._view_cache.config.row_pivots.length;\n        let max_scroll_column = num_columns;\n        while (width < this._container_size.width && max_scroll_column >= 0) {\n            max_scroll_column--;\n            width += this._column_sizes.indices[max_scroll_column + scroll_index_offset] || 60;\n        }\n\n        return Math.min(num_columns - 1, max_scroll_column + 1);\n    }\n\n    /**\n     * Determines whether the viewport is identical in row and column axes to\n     * the previous viewport rendered, for throttling identical render requests,\n     * e.g. when the logical (row-wise) viewport does not change, but the pixel\n     * viewport has moved a few px.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} {start_col, end_col, start_row, end_row}\n     * @returns\n     */\n    _validate_viewport({start_col, end_col, start_row, end_row}) {\n        start_row = Math.floor(start_row);\n        end_row = Math.ceil(end_row);\n        start_col = Math.floor(start_col);\n        end_col = Math.ceil(end_col);\n        const invalid_column = this._start_col !== start_col;\n        const invalid_row = this._start_row !== start_row || this._end_row !== end_row || this._end_col !== end_col;\n        this._start_col = start_col;\n        this._end_col = end_col;\n        this._start_row = start_row;\n        this._end_row = end_row;\n        return {invalid_column, invalid_row};\n    }\n\n    _calc_scrollable_column_width(num_columns) {\n        let scroll_index_offset = this._view_cache.config.row_pivots.length;\n        const max_scroll_column = this._max_scroll_column(num_columns);\n        let cidx = scroll_index_offset,\n            virtual_width = 0;\n\n        while (cidx < max_scroll_column + scroll_index_offset) {\n            virtual_width += this._column_sizes.indices[cidx] || 60;\n            cidx++;\n        }\n\n        return virtual_width;\n    }\n\n    /**\n     * Updates the `virtual_panel` width based on view state.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} invalid\n     */\n    _update_virtual_panel_width(invalid, num_columns) {\n        if (invalid) {\n            if (this._virtual_mode === \"vertical\" || this._virtual_mode === \"none\") {\n                this._virtual_panel.style.width = this._column_sizes.indices.reduce((x, y) => x + y, 0) + \"px\";\n            } else {\n                const virtual_width = this._calc_scrollable_column_width(num_columns);\n                if (virtual_width !== 0) {\n                    const panel_width = this._container_size.width + virtual_width + 2;\n                    this._virtual_panel.style.width = panel_width + \"px\";\n                } else {\n                    this._virtual_panel.style.width = \"1px\";\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates the `virtual_panel` height based on the view state.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} nrows\n     */\n    _update_virtual_panel_height(nrows) {\n        const {row_height = 19} = this._column_sizes;\n        const header_height = this._view_cache.config.column_pivots.length * row_height;\n        let virtual_panel_px_size;\n        if (this._virtual_mode === \"horizontal\" || this._virtual_mode === \"none\") {\n            virtual_panel_px_size = nrows * row_height + header_height;\n        } else {\n            //const {height} = this._container_size;\n            // TODO use cached height?\n            const zoom_factor = this.clientHeight / (this._table_clip.offsetHeight - header_height);\n            virtual_panel_px_size = Math.min(BROWSER_MAX_HEIGHT, nrows * row_height * zoom_factor);\n        }\n        this._virtual_panel.style.height = `${virtual_panel_px_size}px`;\n    }\n\n    /**\n     * Draws this virtual panel, given an object of render options that allow\n     * the implementor to fine tune the individual render frames based on the\n     * interaction and previous render state.\n     *\n     * @public\n     * @memberof RegularVirtualTableViewModel\n     * @param {DrawOptions} [options]\n     * @param {boolean} [options.invalid_viewport=true]\n     * @param {boolean} [options.preserve_width=false]\n     */\n    @throttlePromise\n    async draw(options = {}) {\n        const __debug_start_time__ = DEBUG && performance.now();\n        const {invalid_viewport = true, preserve_width = false} = options;\n        const {num_columns, num_rows} = await this._view_cache.view(0, 0, 0, 0);\n        this._container_size = {\n            width: this._virtual_mode === \"none\" || this._virtual_mode === \"vertical\" ? Infinity : this._table_clip.clientWidth,\n            height: this._virtual_mode === \"none\" || this._virtual_mode === \"horizontal\" ? Infinity : this._table_clip.clientHeight,\n        };\n\n        this._update_virtual_panel_height(num_rows);\n        if (!preserve_width) {\n            this._update_virtual_panel_width(invalid_viewport, num_columns);\n        }\n\n        const viewport = this._calculate_viewport(num_rows, num_columns);\n        const {invalid_row, invalid_column} = this._validate_viewport(viewport);\n        if (this._invalid_schema || invalid_row || invalid_column || invalid_viewport) {\n            let autosize_cells = [],\n                needs_sub_cell_update = true;\n            for await (let last_cells of this.table_model.draw(this._container_size, this._view_cache, this._selected_id, preserve_width, viewport, num_columns)) {\n                if (last_cells !== undefined) {\n                    autosize_cells = autosize_cells.concat(last_cells);\n                }\n\n                // We want to perform this before the next event loop so there\n                // is no scroll jitter, but only on the first iteration as\n                // subsequent viewports are incorrect.\n                if (needs_sub_cell_update) {\n                    this.update_sub_cell_offset(viewport);\n                    needs_sub_cell_update = false;\n                }\n\n                this._is_styling = true;\n                const callbacks = this._style_callbacks;\n                for (const callback of callbacks) {\n                    await callback({detail: this});\n                }\n\n                this._is_styling = false;\n                if (!this._invalidated && last_cells !== undefined) {\n                    break;\n                }\n\n                this._invalidated = false;\n            }\n\n            this.table_model.autosize_cells(autosize_cells);\n            this.table_model.header.reset_header_cache();\n            if (!preserve_width) {\n                this._update_virtual_panel_width(this._invalid_schema || invalid_column, num_columns);\n            }\n            this._invalid_schema = false;\n        } else {\n            this.update_sub_cell_offset(viewport);\n        }\n\n        if (DEBUG) {\n            log_perf(performance.now() - __debug_start_time__);\n        }\n    }\n\n    update_sub_cell_offset(viewport) {\n        const y_offset = this._column_sizes.row_height * (viewport.start_row % 1) || 0;\n        const x_offset = this._column_sizes.indices[(this.table_model._row_headers_length || 0) + Math.floor(viewport.start_col)] * (viewport.start_col % 1) || 0;\n        let style = this._sub_cell_style.sheet?.cssRules[0].style;\n        if (style) {\n            style.setProperty(`--regular-table--clip-x`, `${x_offset}px`);\n            style.setProperty(`--regular-table--clip-y`, `${y_offset}px`);\n            style.setProperty(`--regular-table--transform-x`, `-${x_offset}px`);\n            style.setProperty(`--regular-table--transform-y`, `-${y_offset}px`);\n        }\n    }\n}\n\n/**\n * Options for the draw method.\n *\n * @public\n * @typedef DrawOptions\n * @type {object}\n * @property {boolean} [invalid_viewport]\n * @property {boolean} [preserve_width]\n */\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {METADATA_MAP} from \"./constants\";\nimport {RegularVirtualTableViewModel} from \"./scroll_panel\";\nimport {throttlePromise} from \"./utils\";\n\n/**\n * WHen enabled, override iOS overscroll behavior by emulating scroll position\n * in JavaScript.  This prevents \"bounce\" on edges, but it also removes scroll\n * inertia.  This waspreviously enabled by default in `regular-table<=0.4.3`,\n * but this version also had bugged (exaggerated) position calculation.\n * As `0.5.0` introduces sub-cell scrolling by defualt, this is now disabled by\n * default as well.\n */\nconst IOS_DISABLE_OVERSCROLL = false;\n\n/**\n *\n *\n * @class RegularViewEventModel\n * @extends {RegularVirtualTableViewModel}\n */\nexport class RegularViewEventModel extends RegularVirtualTableViewModel {\n    register_listeners() {\n        // // TODO see `_on_click_or_dblclick` method jsdoc\n        // this.addEventListener(\"dblclick\", this._on_dblclick.bind(this));\n\n        this.addEventListener(\"mousedown\", this._on_click_or_dblclick.bind(this));\n        this.addEventListener(\"scroll\", this._on_scroll.bind(this), {\n            passive: true,\n        });\n\n        this._register_glitch_scroll_listeners();\n    }\n\n    /**\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     * @returns\n     */\n    _on_scroll(event) {\n        event.stopPropagation();\n        this.draw({invalid_viewport: false});\n    }\n\n    /**\n     * Modern and mobile browsers implement complex scroll behavior to\n     * implement fancy touch and intertia effects;  these must be intercepted\n     * and disabled to achieve clean virtual scrolling in the presence of a\n     * `fixed` element.\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     */\n    _register_glitch_scroll_listeners() {\n        this.addEventListener(\"mousewheel\", this._on_mousewheel.bind(this));\n        if (IOS_DISABLE_OVERSCROLL) {\n            this.addEventListener(\"touchmove\", this._on_touchmove.bind(this));\n            this.addEventListener(\"touchstart\", this._on_touchstart.bind(this), {\n                passive: true,\n            });\n        }\n    }\n    /**\n     * Mousewheel must precalculate in addition to `_on_scroll` to prevent\n     * visual artifacts due to scrolling \"inertia\" on modern browsers.\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     * @param {*} event\n     */\n    _on_mousewheel(event) {\n        if (!window.safari) {\n            // **** Apple\n            return;\n        }\n\n        const {clientWidth, clientHeight, scrollTop, scrollLeft} = this;\n        event.preventDefault();\n        event.returnValue = false;\n        const total_scroll_height = Math.max(1, this._virtual_panel.offsetHeight - clientHeight);\n        const total_scroll_width = Math.max(1, this._virtual_panel.offsetWidth - clientWidth);\n        this.scrollTop = Math.max(0, Math.min(total_scroll_height, scrollTop + event.deltaY));\n        this.scrollLeft = Math.max(0, Math.min(total_scroll_width, scrollLeft + event.deltaX));\n        this._on_scroll(event);\n    }\n\n    /**\n     * Touchmove/touchstart must precalculate in addition to `_on_scroll` to\n     * prevent visual artifacts due to scrolling \"inertia\" on mobile browsers.\n     * This has the unfortunate side-effect of disabling scroll intertia.\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     * @param {*} event\n     * @returns\n     */\n    _on_touchmove(event) {\n        event.stopPropagation();\n        event.preventDefault();\n        event.returnValue = false;\n        const {clientWidth, clientHeight} = this;\n        const total_scroll_height = Math.max(1, this._virtual_panel.offsetHeight - clientHeight);\n        const total_scroll_width = Math.max(1, this._virtual_panel.offsetWidth - clientWidth);\n        this.scrollTop = Math.min(total_scroll_height, this._memo_scroll_top + (this._memo_touch_startY - event.touches[0].pageY));\n        this.scrollLeft = Math.min(total_scroll_width, this._memo_scroll_left + (this._memo_touch_startX - event.touches[0].pageX));\n        this._on_scroll(event);\n    }\n\n    _on_touchstart(event) {\n        this._memo_touch_startY = event.touches[0].pageY;\n        this._memo_touch_startX = event.touches[0].pageX;\n        this._memo_scroll_top = this.scrollTop;\n        this._memo_scroll_left = this.scrollLeft;\n    }\n\n    /**\n     * Handles double-click header width override reset.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} event\n     * @returns\n     */\n    async _on_dblclick(event) {\n        let element = event.target;\n        while (element.tagName !== \"TD\" && element.tagName !== \"TH\") {\n            element = element.parentElement;\n            if (!this.contains(element)) {\n                return;\n            }\n        }\n\n        const is_resize = event.target.classList.contains(\"rt-column-resize\");\n        const metadata = METADATA_MAP.get(element);\n        if (is_resize) {\n            event.stopImmediatePropagation();\n            // await new Promise(queueMicrotask);\n            element.style.minWidth = \"\";\n            element.style.maxWidth = \"\";\n            if (event.shiftKey) {\n                this._column_sizes.override = [];\n                this._column_sizes.auto = [];\n                this._column_sizes.indices = [];\n            } else {\n                this._column_sizes.override[metadata.size_key] = undefined;\n                this._column_sizes.auto[metadata.size_key] = undefined;\n                this._column_sizes.indices[metadata.size_key] = undefined;\n            }\n\n            for (const row of event.shiftKey ? [this.table_model.header.cells[this.table_model.header.cells.length - 1], ...this.table_model.body.cells] : this.table_model.body.cells) {\n                for (const td of event.shiftKey ? row : [row[metadata._virtual_x]]) {\n                    if (!td) {\n                        continue;\n                    }\n\n                    td.style.minWidth = \"\";\n                    td.style.maxWidth = \"\";\n                    td.classList.remove(\"rt-cell-clip\");\n                }\n            }\n\n            await this.draw();\n        }\n    }\n\n    /**\n     * Dispatches all click events to other handlers, depending on\n     * `event.target`.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} event\n     * @returns\n     */\n    async _on_click(event) {\n        if (event.button !== 0) {\n            return;\n        }\n\n        let element = event.target;\n        while (element.tagName !== \"TD\" && element.tagName !== \"TH\") {\n            element = element.parentElement;\n            if (!this.contains(element)) {\n                return;\n            }\n        }\n\n        const is_resize = event.target.classList.contains(\"rt-column-resize\");\n        const metadata = METADATA_MAP.get(element);\n        if (is_resize) {\n            this._on_resize_column(event, element, metadata);\n            event.stopImmediatePropagation();\n        }\n    }\n\n    /**\n     * `dblclick` event does not work reliably for some reason so dispatch this\n     * event in JavaScript instead.\n     * @param {`*`} event\n     */\n    async _on_click_or_dblclick(event) {\n        const now = performance.now();\n        if (this._last_clicked_time && now - this._last_clicked_time < 500) {\n            this._last_clicked_time = now;\n            await this._on_dblclick(event);\n        } else {\n            this._last_clicked_time = now;\n            await this._on_click(event);\n        }\n    }\n\n    /**\n     * Regular event for column resize.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} event\n     * @param {*} element\n     * @param {*} metadata\n     */\n    _on_resize_column(event, element, metadata) {\n        const {_virtual_x, size_key} = metadata;\n        const start = event.pageX;\n        const header_x = _virtual_x + element.colSpan - 1;\n        const header_element = this.table_model.header.get_column_header(header_x);\n        const width = this._column_sizes.indices[size_key];\n        const move = (event) => this._on_resize_column_move(event, header_element, start, width, size_key, header_x);\n        const up = () => {\n            document.removeEventListener(\"mousemove\", move);\n            document.removeEventListener(\"mouseup\", up);\n            const override_width = this._column_sizes.override[size_key];\n            const should_redraw = this._column_sizes.indices[size_key] !== override_width;\n            this._column_sizes.indices[size_key] = override_width;\n            if (should_redraw) {\n                this.draw();\n            }\n        };\n\n        document.addEventListener(\"mousemove\", move);\n        document.addEventListener(\"mouseup\", up);\n    }\n\n    /**\n     * Regular event for mouse movement when resizing a column.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} event\n     * @param {*} th\n     * @param {*} start\n     * @param {*} width\n     * @param {*} metadata\n     */\n    @throttlePromise\n    async _on_resize_column_move(event, th, start, width, size_key, virtual_x) {\n        await new Promise(setTimeout);\n        const diff = event.pageX - start;\n        const override_width = Math.max(1, width + diff);\n        this._column_sizes.override[size_key] = override_width;\n\n        // If the column is smaller, new columns may need to be fetched, so\n        // redraw, else just update the DOM widths as if redrawn.\n        if (diff < 0) {\n            await this.draw({preserve_width: true});\n        } else {\n            th.style.minWidth = override_width + \"px\";\n            th.style.maxWidth = override_width + \"px\";\n            const auto_width = this._column_sizes.auto[size_key];\n            for (const row of this.table_model.body.cells) {\n                const td = row[virtual_x];\n                if (td) {\n                    td.style.maxWidth = td.style.minWidth = override_width + \"px\";\n                    td.classList.toggle(\"rt-cell-clip\", auto_width > override_width);\n                }\n            }\n        }\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {METADATA_MAP} from \"./constants\";\n\n/******************************************************************************\n *\n * View Model\n *\n */\n\nclass ElemFactory {\n    constructor(name) {\n        this._name = name;\n        this._elements = [];\n        this._index = 0;\n    }\n\n    reset() {\n        this._index = 0;\n    }\n\n    get() {\n        if (!this._elements[this._index]) {\n            this._elements[this._index] = document.createElement(this._name);\n        }\n\n        const elem = this._elements[this._index];\n        this._index += 1;\n        return elem;\n    }\n}\n\nexport class ViewModel {\n    constructor(column_sizes, container, table) {\n        this._column_sizes = column_sizes;\n        this._container = container;\n        this._span_factory = new ElemFactory(\"span\");\n        this.table = table;\n        this.cells = [];\n        this.rows = [];\n    }\n\n    num_columns() {\n        return this._get_row(Math.max(0, this.rows.length - 1)).row_container.length;\n    }\n\n    num_rows() {\n        return this.cells.length;\n    }\n\n    _set_metadata(td, metadata) {\n        METADATA_MAP.set(td, metadata);\n    }\n\n    _get_or_create_metadata(td) {\n        if (td === undefined) {\n            return {};\n        } else if (METADATA_MAP.has(td)) {\n            return METADATA_MAP.get(td);\n        } else {\n            const metadata = {};\n            METADATA_MAP.set(td, metadata);\n            return metadata;\n        }\n    }\n\n    _replace_cell(ridx, cidx) {\n        const {tr, row_container} = this._get_row(ridx);\n        let td = row_container[cidx];\n        if (td) {\n            tr.removeChild(td);\n            row_container.splice(cidx, 1, undefined);\n        }\n        return td;\n    }\n\n    _fetch_cell(ridx, cidx) {\n        if (ridx < 0 || cidx < 0) {\n            return;\n        }\n        const {row_container} = this._get_row(ridx);\n        return row_container[cidx];\n    }\n\n    _get_cell(tag = \"TD\", ridx, cidx) {\n        const {tr, row_container} = this._get_row(ridx);\n        let td = row_container[cidx];\n        if (!td) {\n            if (cidx < row_container.length) {\n                td = row_container[cidx] = document.createElement(tag);\n                tr.insertBefore(\n                    td,\n                    row_container.slice(cidx + 1).find((x) => x)\n                );\n            } else {\n                td = row_container[cidx] = document.createElement(tag);\n                tr.appendChild(td);\n            }\n        }\n        if (td.tagName !== tag) {\n            const new_td = document.createElement(tag);\n            tr.replaceChild(new_td, td);\n            this.cells[ridx].splice(cidx, 1, new_td);\n            td = new_td;\n        }\n        return td;\n    }\n\n    _get_row(ridx) {\n        let tr = this.rows[ridx];\n        if (!tr) {\n            tr = this.rows[ridx] = document.createElement(\"tr\");\n            this.table.appendChild(tr);\n        }\n\n        let row_container = this.cells[ridx];\n        if (!row_container) {\n            row_container = this.cells[ridx] = [];\n        }\n\n        return {tr, row_container};\n    }\n\n    _clean_columns(cidx) {\n        for (let i = 0; i < this.rows.length; i++) {\n            const tr = this.rows[i];\n            const row_container = this.cells[i];\n            this.cells[i] = row_container.slice(0, cidx[i] || cidx);\n            const idx = this.cells[i].filter((x) => x !== undefined).length;\n            while (tr.children[idx]) {\n                tr.removeChild(tr.children[idx]);\n            }\n        }\n    }\n\n    _clean_rows(ridx) {\n        while (this.table.children[ridx]) {\n            this.table.removeChild(this.table.children[ridx]);\n        }\n        this.rows = this.rows.slice(0, ridx);\n        this.cells = this.cells.slice(0, ridx);\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {ViewModel} from \"./view_model\";\n\n/**\n * <thead> view model.  This model accumulates state in the form of\n * column_sizes, which leverages <tables> autosize behavior across\n * virtual pages.\n *\n * @class RegularHeaderViewModel\n */\nexport class RegularHeaderViewModel extends ViewModel {\n    constructor(...args) {\n        super(...args);\n        this._group_header_cache = [];\n        this._offset_cache = [];\n    }\n\n    _draw_group_th(offset_cache, d, column) {\n        const th = this._get_cell(\"TH\", d, offset_cache[d] || 0);\n        offset_cache[d] += 1;\n        th.removeAttribute(\"colspan\");\n        th.style.minWidth = \"0\";\n\n        th.textContent = \"\";\n        if (column instanceof HTMLElement) {\n            th.appendChild(column);\n        } else {\n            const span = this._span_factory.get(\"span\");\n            span.textContent = column;\n            th.appendChild(span);\n        }\n\n        const resizeSpan = this._span_factory.get(\"span\");\n        resizeSpan.className = \"rt-column-resize\";\n        th.appendChild(resizeSpan);\n\n        return th;\n    }\n\n    _draw_group(column, column_name, th) {\n        const metadata = this._get_or_create_metadata(th);\n        metadata.column_header = column;\n        metadata.value = column_name;\n        metadata.value = column_name;\n        return metadata;\n    }\n\n    _draw_th(column, column_name, th, cidx, size_key) {\n        const metadata = this._get_or_create_metadata(th);\n        metadata.column_header = column;\n        metadata.value = column_name;\n        metadata.size_key = size_key.length ? size_key[0] : size_key; // FIXME\n\n        if (!(size_key.length > 1)) {\n            const override_width = this._column_sizes.override[metadata.size_key];\n            const auto_width = this._column_sizes.auto[metadata.size_key];\n            if (override_width) {\n                th.classList.toggle(\"rt-cell-clip\", auto_width > override_width);\n                th.style.minWidth = override_width + \"px\";\n                th.style.maxWidth = override_width + \"px\";\n            } else if (auto_width) {\n                th.classList.remove(\"rt-cell-clip\");\n                th.style.maxWidth = \"\";\n                th.style.minWidth = auto_width + \"px\";\n            } else {\n                th.style.maxWidth = \"\";\n                th.style.maxWidth = \"\";\n            }\n        }\n\n        return metadata;\n    }\n\n    get_column_header(cidx) {\n        return this._get_cell(\"TH\", this.num_rows() - 1, cidx);\n    }\n\n    draw(alias, parts, colspan, x, size_key, x0, _virtual_x) {\n        const header_levels = parts?.length; //config.column_pivots.length + 1;\n        if (header_levels === 0) return;\n        let th, metadata, column_name;\n        for (let d = 0; d < header_levels; d++) {\n            column_name = parts[d] ? parts[d] : \"\";\n            this._offset_cache[d] = this._offset_cache[d] || 0;\n            if (d < header_levels - 1) {\n                if (this._group_header_cache?.[d]?.[0]?.value === column_name) {\n                    th = this._group_header_cache[d][1];\n                    this._group_header_cache[d][2] += 1;\n                    if (colspan === 1) {\n                        this._group_header_cache[d][0].row_header_x = size_key;\n                    }\n                    th.setAttribute(\"colspan\", this._group_header_cache[d][2]);\n                } else {\n                    th = this._draw_group_th(this._offset_cache, d, column_name);\n                    metadata = this._draw_group(parts, column_name, th);\n                    this._group_header_cache[d] = [metadata, th, 1];\n                }\n            } else {\n                th = this._draw_group_th(this._offset_cache, d, column_name);\n\n                // Update the group header's metadata such that each group\n                // header has the same metadata coordinates of its rightmost\n                // column.\n                metadata = this._draw_th(alias || parts, column_name, th, x, size_key);\n                for (const [group_meta] of this._group_header_cache) {\n                    group_meta.size_key = metadata.size_key;\n                }\n                th.removeAttribute(\"colspan\");\n            }\n\n            th.classList.toggle(\"rt-group-corner\", x === undefined);\n            if (metadata) {\n                metadata.x = typeof x === \"undefined\" ? x : Math.floor(x);\n                metadata.column_header_y = d;\n                metadata.x0 = Math.floor(x0);\n                metadata._virtual_x = _virtual_x;\n                if (colspan === 1) {\n                    metadata.row_header_x = size_key;\n                }\n            }\n        }\n\n        this._clean_rows(this._offset_cache.length);\n        return {th, metadata};\n    }\n\n    clean() {\n        this._clean_columns(this._offset_cache);\n    }\n\n    reset_header_cache() {\n        this._offset_cache = [];\n        this._group_header_cache = [];\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {ViewModel} from \"./view_model\";\n\n/**\n * <tbody> view model.\n *\n * @class RegularBodyViewModel\n */\nexport class RegularBodyViewModel extends ViewModel {\n    _draw_td(tagName, ridx, val, cidx, {column_name}, {ridx_offset}, size_key) {\n        const td = this._get_cell(tagName, ridx, cidx);\n        const metadata = this._get_or_create_metadata(td);\n        metadata.y = ridx + Math.floor(ridx_offset);\n        metadata.size_key = size_key;\n        if (tagName === \"TD\") {\n            metadata.column_header = column_name;\n        }\n        const override_width = this._column_sizes.override[metadata.size_key];\n        if (override_width) {\n            const auto_width = this._column_sizes.auto[metadata.size_key];\n            td.classList.toggle(\"rt-cell-clip\", auto_width > override_width);\n            td.style.minWidth = override_width + \"px\";\n            td.style.maxWidth = override_width + \"px\";\n        } else {\n            td.classList.remove(\"rt-cell-clip\");\n            td.style.minWidth = \"\";\n            td.style.maxWidth = \"\";\n        }\n\n        if (metadata.value !== val) {\n            if (val instanceof HTMLElement) {\n                td.textContent = \"\";\n                td.appendChild(val);\n            } else {\n                td.textContent = val;\n            }\n        }\n\n        metadata.value = val;\n        return {td, metadata};\n    }\n\n    draw(container_height, column_state, view_state, th = false, x, x0, size_key) {\n        const {cidx, column_data, row_headers, column_data_listener_metadata} = column_state;\n        let {row_height} = view_state;\n        let metadata;\n        const ridx_offset = [],\n            tds = [];\n        let ridx = 0;\n        const cidx_offset = [];\n        for (let i = 0; i < (th ? view_state.row_headers_length : 1); i++) {\n            ridx = 0;\n\n            for (const val of column_data) {\n                const id = row_headers?.[ridx];\n                let obj;\n                if (th) {\n                    const row_header = val[i];\n                    const prev_row = this._fetch_cell(ridx - (ridx_offset[i] || 1), cidx + i);\n                    const prev_row_metadata = this._get_or_create_metadata(prev_row);\n\n                    const prev_col = this._fetch_cell(ridx, cidx + i - (cidx_offset[ridx] || 1));\n                    const prev_col_metadata = this._get_or_create_metadata(prev_col);\n\n                    if (prev_col && (prev_col_metadata.value === row_header || row_header === undefined) && !prev_col.hasAttribute(\"rowspan\")) {\n                        cidx_offset[ridx] = cidx_offset[ridx] ? cidx_offset[ridx] + 1 : 2;\n                        prev_col.setAttribute(\"colspan\", cidx_offset[ridx]);\n                        this._replace_cell(ridx, cidx + i);\n                    } else if (prev_row && prev_row_metadata.value === row_header && !prev_row.hasAttribute(\"colspan\")) {\n                        ridx_offset[i] = ridx_offset[i] ? ridx_offset[i] + 1 : 2;\n                        prev_row.setAttribute(\"rowspan\", ridx_offset[i]);\n                        this._replace_cell(ridx, cidx + i);\n                    } else {\n                        obj = this._draw_td(\"TH\", ridx, row_header, cidx + i, column_state, view_state, i);\n                        obj.td.style.display = \"\";\n                        obj.td.removeAttribute(\"rowspan\");\n                        obj.td.removeAttribute(\"colspan\");\n                        obj.metadata.row_header = val;\n                        obj.metadata.row_header_x = i;\n                        obj.metadata.y0 = Math.floor(view_state.ridx_offset);\n                        obj.metadata.y1 = Math.ceil(view_state.y1);\n                        obj.metadata._virtual_x = i;\n                        if (typeof x0 !== \"undefined\") {\n                            obj.metadata.x0 = Math.floor(x0);\n                        }\n                        ridx_offset[i] = 1;\n                        cidx_offset[ridx] = 1;\n                        tds[i] = obj;\n                    }\n                } else {\n                    obj = this._draw_td(\"TD\", ridx, val, cidx, column_state, view_state, size_key);\n                    if (column_data_listener_metadata) {\n                        obj.metadata.user = column_data_listener_metadata[ridx];\n                    }\n\n                    obj.metadata.x = typeof x === \"undefined\" ? x : Math.floor(x);\n                    obj.metadata.x1 = Math.ceil(view_state.x1);\n                    obj.metadata.row_header = id || [];\n                    obj.metadata.y0 = Math.floor(view_state.ridx_offset);\n                    obj.metadata.y1 = Math.ceil(view_state.y1);\n                    obj.metadata.dx = Math.floor(x - x0);\n                    obj.metadata.dy = obj.metadata.y - Math.floor(obj.metadata.y0);\n                    obj.metadata._virtual_x = cidx;\n                    if (typeof x0 !== \"undefined\") {\n                        obj.metadata.x0 = Math.floor(x0);\n                    }\n\n                    tds[0] = obj;\n                }\n\n                ridx++;\n                metadata = obj ? obj.metadata : metadata;\n                row_height = row_height || obj?.td.offsetHeight;\n                if (ridx * row_height > container_height) {\n                    break;\n                }\n            }\n        }\n        this._clean_rows(ridx);\n        return {tds, ridx, metadata, row_height};\n    }\n\n    clean({ridx, cidx}) {\n        this._clean_rows(ridx);\n        this._clean_columns(cidx);\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {RegularHeaderViewModel} from \"./thead\";\nimport {RegularBodyViewModel} from \"./tbody\";\nimport {html} from \"./utils\";\n\n/**\n * <table> view model.  In order to handle unknown column width when `draw()`\n * is called, this model will iteratively fetch more data to fill in columns\n * until the page is complete, and makes some column viewport estimations\n * when this information is not availble.\n *\n * @class RegularTableViewModel\n */\nexport class RegularTableViewModel {\n    constructor(table_clip, column_sizes, element) {\n        this.clear(element);\n        const [table] = element.children;\n        const [thead, tbody] = table.children;\n        this.table = table;\n        this._column_sizes = column_sizes;\n        this.header = new RegularHeaderViewModel(column_sizes, table_clip, thead);\n        this.body = new RegularBodyViewModel(column_sizes, table_clip, tbody);\n        this.fragment = document.createDocumentFragment();\n    }\n\n    num_columns() {\n        return this.header.num_columns();\n    }\n\n    clear(element) {\n        element.innerHTML = html`\n            <table cellspacing=\"0\">\n                <thead></thead>\n                <tbody></tbody>\n            </table>\n        `;\n    }\n\n    /**\n     * Calculate amendments to auto size from this render pass.\n     *\n     * @param {*} last_cells\n     * @param {*} {columns, column_pivots}\n     * @memberof RegularTableViewModel\n     */\n    autosize_cells(last_cells) {\n        while (last_cells.length > 0) {\n            const [cell, metadata, row_height_cell] = last_cells.pop();\n            let offsetWidth;\n            const style = getComputedStyle(cell);\n            if (style.boxSizing !== \"border-box\") {\n                offsetWidth = cell.clientWidth;\n                offsetWidth -= style.paddingLeft ? parseFloat(style.paddingLeft) : 0;\n                offsetWidth -= style.paddingRight ? parseFloat(style.paddingRight) : 0;\n            } else {\n                offsetWidth = parseFloat(style.width);\n            }\n            this._column_sizes.row_height = this._column_sizes.row_height || row_height_cell.offsetHeight;\n            this._column_sizes.indices[metadata.size_key] = offsetWidth;\n            const is_override = this._column_sizes.override[metadata.size_key] !== undefined;\n            if (offsetWidth && !is_override) {\n                this._column_sizes.auto[metadata.size_key] = offsetWidth;\n            }\n\n            if (cell.style.minWidth === \"0px\") {\n                cell.style.minWidth = `${offsetWidth}px`;\n            }\n        }\n    }\n\n    async *draw(container_size, view_cache, selected_id, preserve_width, viewport, num_columns) {\n        const {width: container_width, height: container_height} = container_size;\n        const {view, config} = view_cache;\n        let {data, row_headers, column_headers, metadata: data_listener_metadata} = await view(\n            Math.floor(viewport.start_col),\n            Math.floor(viewport.start_row),\n            Math.ceil(viewport.end_col),\n            Math.ceil(viewport.end_row)\n        );\n\n        const {start_row: ridx_offset = 0, start_col: x0 = 0, end_col: x1 = 0, end_row: y1 = 0} = viewport;\n\n        // pad row_headers for embedded renderer\n        // TODO maybe dont need this - perspective compat\n        if (row_headers) {\n            this._row_headers_length = row_headers.reduce((max, x) => Math.max(max, x.length), 0);\n            row_headers = row_headers.map((x) => {\n                x.length = this._row_headers_length;\n                return x;\n            });\n        }\n\n        view_cache.config.column_pivots = Array.from(Array(column_headers?.[0]?.length || 0).keys());\n        view_cache.config.row_pivots = Array.from(Array(row_headers?.[0]?.length || 0).keys());\n        const sub_cell_offset = this._column_sizes.indices[(this._row_headers_length || 0) + Math.floor(viewport.start_col)] || 0;\n\n        const view_state = {\n            viewport_width: 0,\n            selected_id,\n            ridx_offset,\n            sub_cell_offset,\n            x0: x0,\n            x1: x1,\n            y1: y1,\n            row_height: this._column_sizes.row_height,\n            row_headers_length: this._row_headers_length,\n        };\n\n        let cont_body,\n            _virtual_x = 0,\n            last_cells = [],\n            first_col = true;\n        if (row_headers?.length > 0) {\n            const column_name = config.row_pivots.join(\",\");\n\n            const column_state = {\n                column_name,\n                cidx: 0,\n                column_data: row_headers,\n                row_headers,\n                first_col,\n            };\n            const size_key = _virtual_x + Math.floor(x0);\n            cont_body = this.body.draw(container_height, column_state, {...view_state, x0: 0}, true, undefined, undefined, size_key);\n            const cont_heads = [];\n            for (let i = 0; i < view_cache.config.row_pivots.length; i++) {\n                const header = this.header.draw(column_name, Array(view_cache.config.column_pivots.length).fill(\"\"), 1, undefined, i, x0, i);\n                if (!!header) {\n                    cont_heads.push(header);\n                }\n            }\n            first_col = false;\n            view_state.viewport_width += cont_heads.reduce((total, {th}, i) => total + (this._column_sizes.indices[i] || th.offsetWidth), 0);\n            view_state.row_height = view_state.row_height || cont_body.row_height;\n            _virtual_x = row_headers[0].length;\n            if (!preserve_width) {\n                for (let i = 0; i < view_cache.config.row_pivots.length; i++) {\n                    const {td, metadata} = cont_body.tds[i] || {};\n                    const {th, metadata: hmetadata} = cont_heads[i] || {};\n                    if (!!td || !!th) {\n                        last_cells.push([th || td, hmetadata || metadata, td || th]);\n                    }\n                }\n            }\n        }\n\n        try {\n            let dcidx = 0;\n            const num_visible_columns = num_columns - viewport.start_col;\n            while (dcidx < num_visible_columns) {\n                // If there is no column for this data, our pre-fetch viewport\n                // estimate was wrong and we'll need to do a mid-render fetch\n                // to get more data.\n                if (!data[dcidx]) {\n                    let missing_cidx = Math.max(viewport.end_col, 0);\n                    viewport.start_col = missing_cidx;\n\n                    // Calculate a new data window width based on how large the\n                    // columns drawn so far take up.  This can either be\n                    // summed if we've drawn/measured these columns before,\n                    // or estimated by avg if the missing columns have never\n                    // been seen by the renderer.\n                    let end_col_offset = 0,\n                        size_extension = 0;\n                    while (this._column_sizes.indices.length > _virtual_x + x0 + end_col_offset + 1 && size_extension + view_state.viewport_width < container_width) {\n                        end_col_offset++;\n                        size_extension += this._column_sizes.indices[_virtual_x + x0 + end_col_offset];\n                    }\n\n                    if (size_extension + view_state.viewport_width < container_width) {\n                        const estimate = Math.min(num_columns, missing_cidx + 5); //Math.ceil(((dcidx + end_col_offset) * container_width) / (view_state.viewport_width + size_extension) + 1);\n                        viewport.end_col = Math.max(1, Math.min(num_columns, estimate));\n                    } else {\n                        viewport.end_col = Math.max(1, Math.min(num_columns, missing_cidx + end_col_offset));\n                    }\n\n                    // Fetch the new data window extension and append it to the\n                    // cached data page and continue.\n                    const new_col_req = view(Math.floor(viewport.start_col), Math.floor(viewport.start_row), Math.ceil(viewport.end_col), Math.ceil(viewport.end_row));\n                    yield undefined;\n                    const new_col = await new_col_req;\n\n                    if (new_col.data.length === 0) {\n                        // The viewport is size 0, first the estimate, then the\n                        // first-pass render, so really actually abort now.\n                        yield last_cells;\n                        return;\n                    }\n\n                    viewport.end_col = viewport.start_col + new_col.data.length;\n                    for (let i = 0; i < new_col.data.length; i++) {\n                        data[dcidx + i] = new_col.data[i];\n                        if (new_col.metadata) {\n                            data_listener_metadata[dcidx + i] = new_col.metadata[i];\n                        }\n\n                        if (column_headers) {\n                            column_headers[dcidx + i] = new_col.column_headers?.[i];\n                        }\n                    }\n                }\n\n                const column_name = column_headers?.[dcidx] || \"\";\n                const column_data = data[dcidx];\n                const column_data_listener_metadata = data_listener_metadata?.[dcidx];\n                const column_state = {\n                    column_name,\n                    cidx: _virtual_x,\n                    column_data,\n                    column_data_listener_metadata,\n                    row_headers,\n                    first_col,\n                };\n\n                const x = dcidx + x0;\n                const size_key = _virtual_x + Math.floor(x0);\n                const cont_head = this.header.draw(undefined, column_name, undefined, x, size_key, x0, _virtual_x);\n                cont_body = this.body.draw(container_height, column_state, view_state, false, x, x0, size_key);\n                first_col = false;\n                if (!preserve_width) {\n                    for (const {td, metadata} of cont_body.tds) {\n                        last_cells.push([cont_head?.th || td, cont_head?.metadata || metadata, td || cont_head?.th]);\n                    }\n                }\n\n                const last_measured_col_width = this._column_sizes.indices[_virtual_x + Math.floor(x0)];\n                if (last_measured_col_width) {\n                    view_state.viewport_width += last_measured_col_width;\n                } else {\n                    // This is probably wrong since the column has yet to be\n                    // styled, but we'll use it as an estimate and recalc after.\n                    view_state.viewport_width += cont_head?.th?.offsetWidth || cont_body.tds.reduce((x, y) => x + y.td?.offsetWidth, 0);\n                }\n\n                view_state.row_height = view_state.row_height || cont_body.row_height;\n                _virtual_x++;\n                dcidx++;\n\n                if (view_state.viewport_width - view_state.sub_cell_offset > container_width) {\n                    this.body.clean({\n                        ridx: cont_body?.ridx || 0,\n                        cidx: _virtual_x,\n                    });\n                    this.header.clean();\n                    yield last_cells;\n\n                    // If we make it here, this draw() call was invalidated by\n                    // a call to `invalidate()` within a `StyleListener`, so\n                    // recalculate the cumulative width and keep drawing if\n                    // necessary.  Note `last_cells` is a list of 2-tuples but\n                    // we only bind the first var because _eslint_.\n                    view_state.viewport_width = 0;\n                    for (let [td] of last_cells) {\n                        view_state.viewport_width += td.offsetWidth;\n                    }\n\n                    // If there are still enough columns to fill the screen,\n                    // completely end the iteration here, otherwise\n                    // continue iterating to draw another column.\n                    if (view_state.viewport_width - view_state.sub_cell_offset > container_width) {\n                        return;\n                    }\n                }\n            }\n            this.body.clean({ridx: cont_body?.ridx || 0, cidx: _virtual_x});\n            this.header.clean();\n            yield last_cells;\n        } finally {\n            this.body.clean({ridx: cont_body?.ridx || 0, cidx: _virtual_x});\n            this.header.clean();\n            this.body._span_factory.reset();\n            this.header._span_factory.reset();\n        }\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {METADATA_MAP} from \"./constants\";\nimport {RegularViewEventModel} from \"./events\";\nimport {RegularTableViewModel} from \"./table\";\nimport {get_draw_fps} from \"./utils\";\n\nconst VIRTUAL_MODES = [\"both\", \"horizontal\", \"vertical\", \"none\"];\n\n/**\n * The `<regular-table>` custom element.\n *\n * This module has no exports, but importing it has a side effect: the\n * `RegularTableElement` class is registered as a custom element, after which\n * it can be used as a standard DOM element.\n *\n * The documentation in this module defines the instance structure of a\n * `<regular-table>` DOM object instantiated typically, through HTML or any\n * relevent DOM method e.g. `document.createElement(\"perspective-viewer\")` or\n * `document.getElementsByTagName(\"perspective-viewer\")`.\n *\n * @public\n * @extends HTMLElement\n */\nclass RegularTableElement extends RegularViewEventModel {\n    constructor() {\n        super();\n        /** @private */\n        this._column_sizes = {auto: [], override: [], indices: []};\n        /** @private */\n        this._style_callbacks = [];\n        /** @private */\n        this._initialized = false;\n    }\n\n    /* eslint-disable */\n    /**\n     * For internal use by the Custom Elements API: \"Invoked each time the\n     * custom element is appended into a document-connected element\".\n     * Ref: https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     *\n     * @internal\n     * @private\n     * @memberof RegularTableElement\n     */\n    /* eslint-enable */\n    connectedCallback() {\n        if (!this._initialized) {\n            this.create_shadow_dom();\n            this.register_listeners();\n            this.setAttribute(\"tabindex\", \"0\");\n\n            this._initialized = true;\n            this.table_model = new RegularTableViewModel(this._table_clip, this._column_sizes, this);\n        }\n    }\n\n    /**\n     * Reset the viewport of this regular table.\n     *\n     * @internal\n     * @private\n     * @memberof RegularTableElement\n     */\n    _reset_viewport() {\n        /** @private @type {number} */\n        this._start_row = undefined;\n        /** @private @type {number} */\n        this._end_row = undefined;\n        /** @private @type {number} */\n        this._start_col = undefined;\n        /** @private @type {number} */\n        this._end_col = undefined;\n    }\n\n    /**\n     * Reset the scroll position of this regular table back to the origin.\n     *\n     * @internal\n     * @private\n     * @memberof RegularTableElement\n     */\n    _reset_scroll() {\n        this._column_sizes.indices = [];\n        this.scrollTop = 0;\n        this.scrollLeft = 0;\n        this._reset_viewport();\n    }\n\n    /**\n     * Reset column autosizing, such that column sizes will be recalculated\n     * on the next draw() call.\n     *\n     * @internal\n     * @protected\n     * @memberof RegularTableElement\n     */\n    _resetAutoSize() {\n        this._column_sizes.auto = [];\n        this._column_sizes.override = [];\n        this._column_sizes.indices = [];\n\n        for (let i = 0; i < this.table_model.header.num_columns(); i++) {\n            const th = this.table_model.header.get_column_header(i);\n            th.style.minWidth = \"\";\n            th.style.maxWidth = \"\";\n        }\n    }\n\n    /**\n     * Clears the current renderer `<table>`.\n     *\n     * @public\n     * @memberof RegularTableElement\n     */\n    clear() {\n        this.table_model = new RegularTableViewModel(this._table_clip, this._column_sizes, this);\n    }\n\n    /**\n     * Adds a style listener callback. The style listeners are called\n     * whenever the <table> is re-rendered, such as through API invocations\n     * of draw() and user-initiated events such as scrolling. Within this\n     * optionally async callback, you can select <td>, <th>, etc. elements\n     * via regular DOM API methods like querySelectorAll().\n     *\n     * Example:\n     * const unsubscribe = table.addStyleListener(() => {\n     *     for (const td of table.querySelectorAll(\"td\")) {\n     *         td.setAttribute(\"contenteditable\", true);\n     *     }\n     * });\n     *\n     * setTimeout(() => {\n     *     unsubscribe();\n     * }, 1000);\n     * @public\n     * @memberof RegularTableElement\n     * @param {function({detail: RegularTableElement}): void} styleListener - A\n     * (possibly async) function that styles the inner <table>.\n     * @returns {function(): void} A function to remove this style listener.\n     */\n    addStyleListener(styleListener) {\n        this._style_callbacks = this._style_callbacks.concat(styleListener);\n\n        let isSubscribed = true;\n\n        const unsubscribe = () => {\n            if (!isSubscribed) {\n                return;\n            }\n            isSubscribed = false;\n\n            const callbacks = (this._style_callbacks = this._style_callbacks.slice());\n            const index = callbacks.indexOf(styleListener);\n            callbacks.splice(index, 1);\n        };\n        return unsubscribe;\n    }\n\n    /**\n     * When called within the execution scope of a function registered to this\n     * `<regular-table>` as a `StyleListener`, invalidate this draw's\n     * dimensions and attempt to draw more columns.  Useful if your\n     * `StyleListener` changes a cells dimensions, otherwise `<regular-table>`\n     * may not draw enough columns to fill the screen.\n     *\n     * @public\n     * @memberof RegularTableElement\n     */\n    invalidate() {\n        if (!this._is_styling) {\n            throw new Error(\"Cannot call `invalidate()` outside of a `StyleListener`\");\n        }\n        /** @private */\n        this._invalidated = true;\n    }\n\n    /**\n     * Returns the `MetaData` object associated with a `<td>` or `<th>`.  When\n     * your `StyleListener` is invoked, use this method to look up additional\n     * `MetaData` about any `HTMLTableCellElement` in the rendered `<table>`.\n     *\n     * Example:\n     * const elems = document.querySelector(\"td:last-child td:last_child\");\n     * const metadata = table.getMeta(elems);\n     * console.log(`Viewport corner is ${metadata.x}, ${metadata.y}`);\n     *\n     * const header = table.getMeta({row_header_x: 1, y: 3}).row_header;\n     * @public\n     * @memberof RegularTableElement\n     * @param {HTMLTableCellElement|Partial<MetaData>} element - The child\n     * element of this `<regular-table>` for which to look up metadata, or a\n     * coordinates-like object to refer to metadata by logical position.\n     * @returns {MetaData} The metadata associated with the element.\n     */\n    getMeta(element) {\n        if (typeof element === \"undefined\") {\n            return;\n        } else if (element instanceof HTMLElement) {\n            return METADATA_MAP.get(element);\n        } else if (element.row_header_x >= 0) {\n            if (element.row_header_x < this._view_cache.config.row_pivots.length) {\n                const td = this.table_model.body._fetch_cell(element.y, element.row_header_x);\n                return this.getMeta(td);\n            }\n        } else if (element.column_header_y >= 0) {\n            if (element.column_header_y < this._view_cache.config.column_pivots.length) {\n                const td = this.table_model.body._fetch_cell(element.column_header_y, element.y);\n                return this.getMeta(td);\n            }\n        } else {\n            return this.getMeta(this.table_model.body._fetch_cell(element.dy, element.dx + this.table_model._row_headers_length));\n        }\n    }\n\n    /**\n     * Get performance statistics about this `<regular-table>`.  Calling this\n     * method resets the internal state, which makes it convenient to measure\n     * performance at regular intervals (see example).\n     *\n     * Example:\n     * const table = document.getElementById(\"my_regular_table\");\n     * setInterval(() => {\n     *     const {real_fps} = table.getDrawFPS();\n     *     console.log(`Measured ${fps} fps`)\n     * });\n     * @public\n     * @memberof RegularTableElement\n     * @returns {Performance} Performance data aggregated since the last\n     * call to `getDrawFPS()`.\n     */\n    getDrawFPS() {\n        return get_draw_fps();\n    }\n\n    /**\n     * Call this method to set the `scrollLeft` and `scrollTop` for this\n     * `<regular-table>` by calculating the position of this `scrollLeft`\n     * and `scrollTop` relative to the underlying widths of its columns\n     * and heights of its rows.\n     *\n     * Example:\n     * table.scrollToCell(1, 3, 10, 30);\n     * @public\n     * @memberof RegularTableElement\n     * @param {number} x - The left most `x` index column to scroll into view.\n     * @param {number} y - The top most `y` index row to scroll into view.\n     */\n    async scrollToCell(x, y) {\n        if (!this._view_cache) {\n            console.warn(\"data listener not configured\");\n            return;\n        }\n\n        const viewport_row_height = this._column_sizes.row_height || 19;\n        const header_height = this._view_cache.config.column_pivots.length * viewport_row_height;\n        const body_height = this._table_clip.offsetHeight - header_height;\n        const row_height_offset = body_height % viewport_row_height;\n        let real_row_height = (this._virtual_panel.offsetHeight - row_height_offset) / this._nrows;\n        this.scrollTop = Math.ceil(real_row_height * y);\n\n        let scroll_left = 0;\n        while (x > 0) {\n            x--;\n            scroll_left += this._column_sizes.indices[x + this._view_cache.config.row_pivots.length] || 60;\n        }\n\n        this.scrollLeft = Math.ceil(scroll_left);\n        await new Promise(requestAnimationFrame);\n        await this.draw.flush();\n    }\n\n    /**\n     * Call this method to set `DataListener` for this `<regular-table>`,\n     * which will be called whenever a new data slice is needed to render.\n     * Calls to `draw()` will fail if no `DataListener` has been set\n     *\n     * Example:\n     * table.setDataListener((x0, y0, x1, y1) => {\n     *     return {\n     *         num_rows: num_rows = DATA[0].length,\n     *         num_columns: DATA.length,\n     *         data: DATA.slice(x0, x1).map(col => col.slice(y0, y1))\n     *     };\n     * })\n     * @public\n     * @memberof RegularTableElement\n     * @param {DataListener} dataListener\n     * `dataListener` is called by to request a rectangular section of data\n     * for a virtual viewport, (x0, y0, x1, y1), and returns a `DataReponse`\n     * object.\n     * @param {Object} options\n     * @param {(\"both\"|\"horizontal\"|\"vertical\"|\"none\")} options.virtual_mode\n     * The `virtual_mode` options flag may be one of \"both\", \"horizontal\",\n     * \"vertical\", or \"none\" indicating which dimensions of the table should be\n     * virtualized (vs. rendering completely).\n     */\n    setDataListener(dataListener, {virtual_mode = \"both\"} = {}) {\n        let schema = {};\n        let config = {\n            row_pivots: [],\n            column_pivots: [],\n        };\n\n        console.assert(VIRTUAL_MODES.indexOf(virtual_mode) > -1, `Unknown virtual_mode ${virtual_mode};  valid options are \"both\" (default), \"horizontal\", \"vertical\" or \"none\"`);\n        /** @private */\n        this._virtual_mode = virtual_mode;\n        /** @private */\n        this._invalid_schema = true;\n        /** @private */\n        this._view_cache = {view: dataListener, config, schema};\n        this._setup_virtual_scroll();\n    }\n\n    /**\n     * This func only exists to provide hints to doc compulation tools.\n     * Should never be run, and even if it is the body of the func will\n     * never execute.\n     *\n     * @internal\n     * @private\n     * @memberof RegularTableElement\n     */\n    __noop_jsdoc_hints() {\n        if (false) {\n            /**\n             * Draws this virtual panel, given an object of render options that\n             * allow the implementor to fine tune the individual render frames\n             * based on the interaction and previous render state.\n             *\n             * @public\n             * @type {(opt?: DrawOptions) => void}\n             * @memberof RegularTableElement\n             * */\n            this.draw = null;\n        }\n    }\n}\n\nif (document.createElement(\"regular-table\").constructor === HTMLElement) {\n    window.customElements.define(\"regular-table\", RegularTableElement);\n}\n\n/**\n * An object with performance statistics about calls to\n * `draw()` from some time interval (captured in milliseconds by the\n * `elapsed` proprty).\n *\n * @public\n * @typedef Performance\n * @type {object}\n * @property {number} avg - Avergage milliseconds per call.\n * @property {number} real_fps - `num_frames` / `elapsed`\n * @property {number} virtual_fps - `elapsed` / `avg`\n * @property {number} num_frames - Number of frames rendered.\n * @property {number} elapsed - Number of milliseconds since last call\n * to `getDrawFPS()`.\n */\n\n/**\n * An object describing virtual rendering metadata about an\n * `HTMLTableCellElement`, use this object to map rendered `<th>` or `<td>`\n * elements back to your `data`, `row_headers` or `column_headers` within\n * listener functions for `addStyleListener()` and `addEventListener()`.\n *\n * Example:\n *\n * MetaData                     (x = 0, column_header_y = 0))\n *                              *-------------------------------------+\n *                              |                                     |\n *                              |                                     |\n *                              +-------------------------------------+\n * (row_header_x = 0, y = 0)    (x = 0, y = 0)\n * *------------------------+   *-------------------------------------+\n * |                        |   |                                     |\n * |                        |   |      (x0, y0)                       |\n * |                        |   |      *---------------*              |\n * |                        |   |      |               |              |\n * |                        |   |      |     * (x, y)  |              |\n * |                        |   |      |               |              |\n * |                        |   |      *---------------* (x1, y1)     |\n * |                        |   |                                     |\n * +------------------------+   +-------------------------------------+\n *\n * @public\n * @typedef MetaData\n * @type {object}\n * @property {number} [x] - The `x` index in your virtual data model.\n * property is only generated for `<td>`, `<th>` from `row_headers`.\n * @property {number} [y] - The `y` index in your virtual data model.\n * property is only generated for `<td>`, `<th>` from `row_headers`.\n * @property {number} [x0] - The `x` index of the viewport origin in\n * your data model, e.g. what was passed to `x0` when your\n * `dataListener` was invoked.\n * @property {number} [y0] - The `y` index of the viewport origin in\n * your data model, e.g. what was passed to `y0` when your\n * `dataListener` was invoked.\n * @property {number} [x1] - The `x` index of the viewport corner in\n * your data model, e.g. what was passed to `x1` when your\n * `dataListener` was invoked.\n * @property {number} [y1] - The `y` index of the viewport corner in\n * your data model, e.g. what was passed to `y1` when your\n * `dataListener` was invoked.\n * @property {number} [dx] - The `x` index in `DataResponse.data`, this\n * property is only generated for `<td>`, and `<th>` from `column_headers`.\n * @property {number} [dy] - The `y` index in `DataResponse.data`, this\n * property is only generated for `<td>`, `<th>` from `row_headers`.\n * @property {number} [column_header_y] - The `y` index in\n * `DataResponse.column_headers[x]`, this property is only generated for `<th>`\n * from `column_headers`.\n * @property {number} [row_header_x] - The `x` index in\n * `DataResponse.row_headers[y]`, this property is only generated for `<th>`\n * from `row_headers`.\n * @property {number} size_key - The unique index of this column in a full\n * `<table>`, which is `x` + (Total Row Header Columns).\n * @property {(string|HTMLElement)[]} [row_header] - The `Array` for this `y` in\n * `DataResponse.row_headers`, if it was provided.\n * @property {(string|HTMLElement)[]} [column_header] - The `Array` for this `x`\n * in `DataResponse.column_headers`, if it was provided.\n * @property {(string|HTMLElement)} [value] - The value dispalyed in the cell or\n * header.\n */\n\n/**\n * The `DataResponse` object describes a rectangular region of a virtual\n * data set, and some associated metadata.  `<regular-table>` will use this\n * object to render the `<table>`, though it may make multiple requests for\n * different regions to achieve a compelte render as it must estimate\n * certain dimensions.  You must construct a `DataResponse` object to\n * implement a `DataListener`.\n *\n * Example:\n * {\n *     \"num_rows\": 26,\n *     \"num_columns\": 3,\n *     \"data\": [\n *         [0, 1],\n *         [\"A\", \"B\"]\n *     ],\n *     \"row_headers\": [\n *         [\"Rowgroup 1\", \"Row 1\"],\n *         [\"Rowgroup 1\", \"Row 2\"]\n *     ],\n *     \"column_headers\": [\n *         [\"Colgroup 1\", \"Column 1\"],\n *         [\"Colgroup 1\", \"Column 2\"]\n *     ]\n * }\n * @public\n * @typedef DataResponse\n * @type {object}\n * @property {(string|HTMLElement)[][]} [column_headers] - A two dimensional\n * `Array` of column group headers, in specificity order.  No `<thead>`\n * will be generated if this property is not provided.\n * @property {(string|HTMLElement)[][]} [row_headers] - A two dimensional\n * `Array` of row group headers, in specificity order.  No `<th>`\n * elements within `<tbody>` will be generated if this property is not\n * provided.\n * @property {(string|HTMLElement)[][]} data - A two dimensional `Array`\n * representing a rectangular section of the underlying data set from\n * (x0, y0) to (x1, y1), arranged in columnar fashion such that\n * `data[x][y]` returns the `y`th row of the `x`th column of the slice.\n * @property {number} num_rows - Total number of rows in the underlying\n * data set.\n * @property {number} num_columns - Total number of columns in the\n * underlying data set.\n */\n\n/**\n * The `DataListener` is similar to a normal event listener function.\n * Unlike a normal event listener, it takes regular arguments (not an\n * `Event`); and returns a `Promise` for a `DataResponse` object for this\n * region (as opposed to returning `void` as a standard event listener).\n *\n * @public\n * @callback DataListener\n * @param {number} x0 - The origin `x` index (column).\n * @param {number} y0 - The origin `y` index (row).\n * @param {number} x1 - The corner `x` index (column).\n * @param {number} y1 - The corner `y` index (row).\n * @returns {Promise<DataResponse>} The resulting `DataResponse`.  Make sure\n * to `resolve` or `reject` the `Promise`, or your `<regular-table>` will\n * never render!\n */\n\n/**\n * Options for the draw method.\n *\n * @public\n * @typedef DrawOptions\n * @type {object}\n * @property {boolean} [invalid_viewport]\n * @property {boolean} [preserve_width]\n */\n\n/**\n * Public summary of table_model type.\n *\n * @public\n * @typedef TableModel\n * @type {object}\n * @property {ViewModel} header\n * @property {ViewModel} body\n * @property {() => number} num_columns\n */\n\n/**\n * Public summary of table_model.header and table_model.body base type.\n *\n * @public\n * @typedef ViewModel\n * @type {object}\n * @property {any} table\n * @property {any[]} cells\n * @property {any[]} rows\n * @property {() => number} num_columns\n * @property {() => number} num_rows\n */\n"],"names":["METADATA_MAP","WeakMap","BROWSER_MAX_HEIGHT","navigator","userAgent","toLowerCase","indexOf","AVG","TOTAL","START","performance","now","html","strings","args","map","str","i","flat","filter","a","join","throttlePromise","target","property","descriptor","f","value","lock_symbol","Symbol","async","undefined","this","result","_resolve","promise","Promise","resolve","invertPromise","call","l","flush","requestAnimationFrame","RegularVirtualTableViewModel","HTMLElement","create_shadow_dom","attachShadow","mode","shadowRoot","innerHTML","style","virtual_panel","table_clip","children","_sub_cell_style","_table_clip","_virtual_panel","_setup_virtual_scroll","_virtual_mode","top","removeProperty","left","contain","_calculate_viewport","nrows","num_columns","start_row","end_row","_calculate_row_range","start_col","end_col","_calculate_column_range","_nrows","height","_container_size","row_height","_column_sizes","header_levels","_view_cache","config","column_pivots","length","total_scroll_height","Math","max","offsetHeight","clientHeight","percent_scroll","ceil","scrollTop","virtual_panel_row_height","relative_nrows","min","_calc_start_column","scroll_index_offset","row_pivots","offset_width","diff","scrollLeft","new_val","indices","Infinity","table_model","width","_max_scroll_column","w","slice","max_scroll_column","_validate_viewport","floor","invalid_column","_start_col","invalid_row","_start_row","_end_row","_end_col","_calc_scrollable_column_width","cidx","virtual_width","_update_virtual_panel_width","invalid","reduce","x","y","panel_width","_update_virtual_panel_height","header_height","virtual_panel_px_size","zoom_factor","options","__debug_start_time__","invalid_viewport","preserve_width","num_rows","view","clientWidth","viewport","_invalid_schema","autosize_cells","needs_sub_cell_update","last_cells","draw","_selected_id","concat","update_sub_cell_offset","_is_styling","callbacks","_style_callbacks","callback","detail","_invalidated","header","reset_header_cache","y_offset","x_offset","_row_headers_length","sheet","_this$_sub_cell_style","cssRules","setProperty","RegularViewEventModel","register_listeners","addEventListener","_on_click_or_dblclick","bind","_on_scroll","passive","_register_glitch_scroll_listeners","event","stopPropagation","_on_mousewheel","window","safari","preventDefault","returnValue","total_scroll_width","offsetWidth","deltaY","deltaX","_on_touchmove","_memo_scroll_top","_memo_touch_startY","touches","pageY","_memo_scroll_left","_memo_touch_startX","pageX","_on_touchstart","element","tagName","parentElement","contains","is_resize","classList","metadata","get","stopImmediatePropagation","minWidth","maxWidth","shiftKey","override","auto","size_key","row","cells","body","td","_virtual_x","remove","button","_on_resize_column","_last_clicked_time","_on_dblclick","_on_click","start","header_x","colSpan","header_element","get_column_header","move","_on_resize_column_move","up","document","removeEventListener","override_width","should_redraw","th","virtual_x","setTimeout","auto_width","toggle","ElemFactory","constructor","name","_name","_elements","_index","reset","createElement","elem","ViewModel","column_sizes","container","table","_container","_span_factory","rows","_get_row","row_container","_set_metadata","set","_get_or_create_metadata","has","_replace_cell","ridx","tr","removeChild","splice","_fetch_cell","_get_cell","tag","insertBefore","find","appendChild","new_td","replaceChild","_clean_columns","idx","_clean_rows","RegularHeaderViewModel","_group_header_cache","_offset_cache","_draw_group_th","offset_cache","d","column","removeAttribute","textContent","span","resizeSpan","className","_draw_group","column_name","column_header","_draw_th","alias","parts","colspan","x0","row_header_x","setAttribute","group_meta","column_header_y","clean","RegularBodyViewModel","_draw_td","val","ridx_offset","container_height","column_state","view_state","column_data","row_headers","column_data_listener_metadata","tds","cidx_offset","row_headers_length","id","obj","row_header","prev_row","prev_row_metadata","prev_col","prev_col_metadata","hasAttribute","display","y0","y1","user","x1","dx","dy","_obj","RegularTableViewModel","clear","thead","tbody","fragment","createDocumentFragment","cell","row_height_cell","pop","getComputedStyle","boxSizing","paddingLeft","parseFloat","paddingRight","is_override","container_size","view_cache","selected_id","container_width","data","column_headers","data_listener_metadata","Array","from","keys","viewport_width","sub_cell_offset","cont_body","first_col","cont_heads","fill","push","total","hmetadata","dcidx","num_visible_columns","missing_cidx","end_col_offset","size_extension","estimate","new_col_req","new_col","_new_col$column_heade","cont_head","last_measured_col_width","_y$td","VIRTUAL_MODES","RegularTableElement","_initialized","connectedCallback","_reset_viewport","_reset_scroll","_resetAutoSize","addStyleListener","styleListener","isSubscribed","index","invalidate","Error","getMeta","getDrawFPS","elapsed","avg","real_fps","num_frames","virtual_fps","get_draw_fps","console","warn","viewport_row_height","row_height_offset","real_row_height","scroll_left","setDataListener","dataListener","virtual_mode","assert","schema","__noop_jsdoc_hints","customElements","define"],"mappings":"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"}